import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// ../../node_modules/semaphore-async-await/dist/Semaphore.js
var require_Semaphore = __commonJS({
  "../../node_modules/semaphore-async-await/dist/Semaphore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve2) {
            resolve2(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t;
      return { next: verb(0), "throw": verb(1), "return": verb(2) };
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f2 = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [0, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f2 = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    exports.__esModule = true;
    var Semaphore = function() {
      function Semaphore2(permits) {
        this.promiseResolverQueue = [];
        this.permits = permits;
      }
      Semaphore2.prototype.getPermits = function() {
        return this.permits;
      };
      Semaphore2.prototype.wait = function() {
        return __awaiter(this, void 0, void 0, function() {
          var _this = this;
          return __generator(this, function(_a) {
            if (this.permits > 0) {
              this.permits -= 1;
              return [2, Promise.resolve(true)];
            }
            return [2, new Promise(function(resolver) {
              return _this.promiseResolverQueue.push(resolver);
            })];
          });
        });
      };
      Semaphore2.prototype.acquire = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.wait()];
          });
        });
      };
      Semaphore2.prototype.waitFor = function(milliseconds) {
        return __awaiter(this, void 0, void 0, function() {
          var _this = this;
          var resolver, promise;
          return __generator(this, function(_a) {
            if (this.permits > 0) {
              this.permits -= 1;
              return [2, Promise.resolve(true)];
            }
            resolver = function(b) {
              return void 0;
            };
            promise = new Promise(function(r) {
              resolver = r;
            });
            this.promiseResolverQueue.push(resolver);
            setTimeout(function() {
              var index = _this.promiseResolverQueue.indexOf(resolver);
              if (index !== -1) {
                _this.promiseResolverQueue.splice(index, 1);
              } else {
              }
              resolver(false);
            }, milliseconds);
            return [2, promise];
          });
        });
      };
      Semaphore2.prototype.tryAcquire = function() {
        if (this.permits > 0) {
          this.permits -= 1;
          return true;
        }
        return false;
      };
      Semaphore2.prototype.drainPermits = function() {
        if (this.permits > 0) {
          var permitCount = this.permits;
          this.permits = 0;
          return permitCount;
        }
        return 0;
      };
      Semaphore2.prototype.signal = function() {
        this.permits += 1;
        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {
          throw new Error("this.permits should never be > 0 when there is someone waiting.");
        } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
          this.permits -= 1;
          var nextResolver = this.promiseResolverQueue.shift();
          if (nextResolver) {
            nextResolver(true);
          }
        }
      };
      Semaphore2.prototype.release = function() {
        this.signal();
      };
      Semaphore2.prototype.execute = function(func) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.wait()];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                _a.trys.push([2, , 4, 5]);
                return [4, func()];
              case 3:
                return [2, _a.sent()];
              case 4:
                this.signal();
                return [
                  7
                  /*endfinally*/
                ];
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      return Semaphore2;
    }();
    exports["default"] = Semaphore;
  }
});

// ../../node_modules/semaphore-async-await/dist/Lock.js
var require_Lock = __commonJS({
  "../../node_modules/semaphore-async-await/dist/Lock.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports.__esModule = true;
    var Semaphore_1 = require_Semaphore();
    var Lock = function(_super) {
      __extends(Lock2, _super);
      function Lock2() {
        return _super.call(this, 1) || this;
      }
      return Lock2;
    }(Semaphore_1["default"]);
    exports.Lock = Lock;
  }
});

// ../../node_modules/semaphore-async-await/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/semaphore-async-await/dist/index.js"(exports) {
    "use strict";
    function __export(m) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    exports.__esModule = true;
    var Semaphore_1 = require_Semaphore();
    exports["default"] = Semaphore_1["default"];
    __export(require_Lock());
  }
});

// ../../node_modules/reflect-metadata/Reflect.js
var Reflect2;
(function(Reflect3) {
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
    var exporter = makeExporter(Reflect3);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect3;
    } else {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory(exporter);
    function makeExporter(target, previous) {
      return function(key, value) {
        if (typeof target[key] !== "function") {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
        }
        if (previous)
          previous(key, value);
      };
    }
  })(function(exporter) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map, key) {
        return hasOwn.call(map, key);
      } : function(map, key) {
        return key in map;
      },
      get: downLevel ? function(map, key) {
        return hasOwn.call(map, key) ? map[key] : void 0;
      } : function(map, key) {
        return map[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var usePolyfill = typeof process === "object" && process["env"] && process["env"]["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
    var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var Metadata = new _WeakMap();
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var metadataMap = GetOrCreateMetadataMap(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return false;
      if (!metadataMap.delete(metadataKey))
        return false;
      if (metadataMap.size > 0)
        return true;
      var targetMetadata = Metadata.get(target);
      targetMetadata.delete(propertyKey);
      if (targetMetadata.size > 0)
        return true;
      Metadata.delete(target);
      return true;
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i = decorators.length - 1; i >= 0; --i) {
        var decorator = decorators[i];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      var targetMetadata = Metadata.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create)
          return void 0;
        targetMetadata = new _Map();
        Metadata.set(O, targetMetadata);
      }
      var metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create)
          return void 0;
        metadataMap = new _Map();
        targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn2)
        return true;
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return false;
      return ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn2)
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return void 0;
      return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        true
      );
      metadataMap.set(MetadataKey, MetadataValue);
    }
    function OrdinaryMetadataKeys(O, P) {
      var ownKeys = OrdinaryOwnMetadataKeys(O, P);
      var parent = OrdinaryGetPrototypeOf(O);
      if (parent === null)
        return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P);
      if (parentKeys.length <= 0)
        return ownKeys;
      if (ownKeys.length <= 0)
        return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
        var key = ownKeys_1[_i];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
        var key = parentKeys_1[_a];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O, P) {
      var keys = [];
      var metadataMap = GetOrCreateMetadataMap(
        O,
        P,
        /*Create*/
        false
      );
      if (IsUndefined(metadataMap))
        return keys;
      var keysObj = metadataMap.keys();
      var iterator = GetIterator(keysObj);
      var k = 0;
      while (true) {
        var next = IteratorStep(iterator);
        if (!next) {
          keys.length = k;
          return keys;
        }
        var nextValue = IteratorValue(next);
        try {
          keys[k] = nextValue;
        } catch (e) {
          try {
            IteratorClose(iterator);
          } finally {
            throw e;
          }
        }
        k++;
      }
    }
    function Type(x) {
      if (x === null)
        return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return x === void 0;
    }
    function IsNull(x) {
      return x === null;
    }
    function IsSymbol(x) {
      return typeof x === "symbol";
    }
    function IsObject(x) {
      return typeof x === "object" ? x !== null : typeof x === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if (hint === "string") {
        var toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      );
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function GetMethod(V, P) {
      var func = V[P];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator = method.call(obj);
      if (!IsObject(iterator))
        throw new TypeError();
      return iterator;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator) {
      var result = iterator.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator) {
      var f2 = iterator["return"];
      if (f2)
        f2.call(iterator);
    }
    function OrdinaryGetPrototypeOf(O) {
      var proto = Object.getPrototypeOf(O);
      if (typeof O !== "function" || O === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype = O.prototype;
      var prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O)
        return proto;
      return constructor;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: void 0, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        }()
      );
      return (
        /** @class */
        function() {
          function Map2() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map2.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map2.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map2.prototype.get = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            return index >= 0 ? this._values[index] : void 0;
          };
          Map2.prototype.set = function(key, value) {
            var index = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index] = value;
            return this;
          };
          Map2.prototype.delete = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            if (index >= 0) {
              var size = this._keys.length;
              for (var i = index + 1; i < size; i++) {
                this._keys[i - 1] = this._keys[i];
                this._values[i - 1] = this._values[i];
              }
              this._keys.length--;
              this._values.length--;
              if (key === this._cacheKey) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map2.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map2.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map2.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map2.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map2.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map2.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map2.prototype._find = function(key, insert) {
            if (this._cacheKey !== key) {
              this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map2;
        }()
      );
      function getKey(key, _) {
        return key;
      }
      function getValue(_, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      return (
        /** @class */
        function() {
          function Set2() {
            this._map = new _Map();
          }
          Object.defineProperty(Set2.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set2.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set2.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set2.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set2.prototype.clear = function() {
            this._map.clear();
          };
          Set2.prototype.keys = function() {
            return this._map.keys();
          };
          Set2.prototype.values = function() {
            return this._map.values();
          };
          Set2.prototype.entries = function() {
            return this._map.entries();
          };
          Set2.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set2.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set2;
        }()
      );
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.get(table, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer, size) {
        for (var i = 0; i < size; ++i)
          buffer[i] = Math.random() * 255 | 0;
        return buffer;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          if (typeof crypto !== "undefined")
            return crypto.getRandomValues(new Uint8Array(size));
          if (typeof msCrypto !== "undefined")
            return msCrypto.getRandomValues(new Uint8Array(size));
          return FillRandomBytes(new Uint8Array(size), size);
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect2 || (Reflect2 = {}));

// ../../node_modules/@sensenet/client-utils/dist/esm/inject/injector.js
var Injector = class _Injector {
  constructor() {
    this.options = {};
    this.cachedSingletons = /* @__PURE__ */ new Map();
    this.remove = (ctor) => this.cachedSingletons.delete(ctor);
  }
  /**
   * Returns the registered Logger instance
   */
  get logger() {
    return this.getInstance(LoggerCollection);
  }
  /**
   * Registers a Logger service to the injector container with the provided loggers.
   */
  useLogging() {
    for (var _len = arguments.length, loggers = new Array(_len), _key = 0; _key < _len; _key++) {
      loggers[_key] = arguments[_key];
    }
    const loggerInstances = loggers.map((l) => this.getInstance(l));
    const collection = this.getInstance(LoggerCollection);
    collection.attachLogger(...loggerInstances);
    this.setExplicitInstance(collection, LoggerCollection);
    return this;
  }
  /**
   * Disposes the Injector object and all its disposable injectables
   */
  async dispose() {
    const singletons = Array.from(this.cachedSingletons.entries()).map((e) => e[1]);
    const disposeRequests = singletons.filter((s) => s !== this).map(async (s) => {
      if (s.dispose) {
        return s.dispose() || Promise.resolve();
      }
    });
    await Promise.all(disposeRequests);
    this.cachedSingletons.clear();
  }
  /**
   * Options object for an injector instance
   */
  /**
   *
   * @param ctor The constructor object (e.g. MyClass)
   * @param dependencies Resolved dependencies (usually provided by the framework)
   */
  getInstance(ctor) {
    let dependencies = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (ctor === this.constructor) {
      return this;
    }
    const meta = _Injector.meta.get(ctor);
    if (!meta) {
      throw Error(`No metadata found for '${ctor.name}'. Dependencies: ${dependencies.map((d) => d.name).join(",")}. Be sure that it's decorated with '@Injectable()' or added explicitly with SetInstance()`);
    }
    if (dependencies.includes(ctor)) {
      throw Error(`Circular dependencies found.`);
    }
    if (meta.options.lifetime === "singleton") {
      const invalidDeps = meta.dependencies.map((dep) => ({
        meta: _Injector.meta.get(dep),
        dep
      })).filter((m) => m.meta && (m.meta.options.lifetime === "scoped" || m.meta.options.lifetime === "transient")).map((i) => i.meta && `${i.dep.name}:${i.meta.options.lifetime}`);
      if (invalidDeps.length) {
        throw Error(`Injector error: Singleton type '${ctor.name}' depends on non-singleton injectables: ${invalidDeps.join(",")}`);
      }
    } else if (meta.options.lifetime === "scoped") {
      const invalidDeps = meta.dependencies.map((dep) => ({
        meta: _Injector.meta.get(dep),
        dep
      })).filter((m) => m.meta && m.meta.options.lifetime === "transient").map((i) => i.meta && `${i.dep.name}:${i.meta.options.lifetime}`);
      if (invalidDeps.length) {
        throw Error(`Injector error: Scoped type '${ctor.name}' depends on transient injectables: ${invalidDeps.join(",")}`);
      }
    }
    if (meta.options.lifetime !== "transient" && this.cachedSingletons.has(ctor)) {
      return this.cachedSingletons.get(ctor);
    }
    const fromParent = meta.options.lifetime === "singleton" && this.options.parent && this.options.parent.getInstance(ctor);
    if (fromParent) {
      return fromParent;
    }
    const deps = meta.dependencies.map((dep) => this.getInstance(dep, [...dependencies, ctor]));
    const newInstance = new ctor(...deps);
    this.setExplicitInstance(newInstance);
    return newInstance;
  }
  /**
   * Sets explicitliy an instance for a key in the store
   * @param instance The created instance
   * @param key The class key to be persisted (optional, calls back to the instance's constructor)
   */
  setExplicitInstance(instance, key) {
    const ctor = key || instance.constructor;
    if (!_Injector.meta.has(ctor)) {
      const meta = Reflect.getMetadata("design:paramtypes", ctor);
      _Injector.meta.set(ctor, {
        dependencies: meta && meta.map((param) => {
          return param;
        }) || [],
        options: {
          ...defaultInjectableOptions,
          lifetime: "explicit"
        }
      });
    }
    if (instance.constructor === this.constructor) {
      throw Error("Cannot set an injector instance as injectable");
    }
    this.cachedSingletons.set(ctor, instance);
  }
  /**
   * Creates a child injector instance
   * @param options Additional injector options
   */
  createChild(options) {
    const i = new _Injector();
    i.options = i.options || options;
    i.options.parent = this;
    return i;
  }
};
Injector.meta = /* @__PURE__ */ new Map();

// ../../node_modules/@sensenet/client-utils/dist/esm/inject/injectable.js
var defaultInjectableOptions = {
  lifetime: "transient"
};
var Injectable = (options) => {
  return (ctor) => {
    const meta = Reflect.getMetadata("design:paramtypes", ctor);
    const metaValue = {
      dependencies: meta && meta.map((param) => {
        return param;
      }) || [],
      options: {
        ...defaultInjectableOptions,
        ...options
      }
    };
    Injector.meta.set(ctor, metaValue);
  };
};

// ../../node_modules/@sensenet/client-utils/dist/esm/logger/abstract-logger.js
var AbstractLoggerScope = "@sensenet/client-utils/AbstractLogger";
var AbstractLogger = class {
  constructor() {
    this.withScope = (scope) => ({
      /**
       * Adds a custom log entry
       */
      addEntry: (entry) => this.addEntry({
        scope,
        ...entry
      }),
      /**
       * Adds a Verbose log entry. Verbose is the noisiest level, rarely (if ever) enabled for a production app.
       */
      verbose: (entry) => this.verbose({
        scope,
        ...entry
      }),
      /**
       * Adds a debug log entry. Debug is used for internal system events that are not necessarily observable from the outside, but useful when determining how something happened.
       */
      debug: (entry) => this.debug({
        scope,
        ...entry
      }),
      /**
       * Adds an Information log entry. Information events describe things happening in the system that correspond to its responsibilities and functions. Generally these are the observable actions the system can perform.
       */
      information: (entry) => this.information({
        scope,
        ...entry
      }),
      /**
       * Adds a Warning log entry. When service is degraded, endangered, or may be behaving outside of its expected parameters, Warning level events are used.
       */
      warning: (entry) => this.warning({
        scope,
        ...entry
      }),
      /**
       * Adds an Error log entry. When functionality is unavailable or expectations broken, an Error event is used.
       */
      error: (entry) => this.error({
        scope,
        ...entry
      }),
      /**
       * Adds a Fatal log entry. The most critical level, Fatal events demand immediate attention.
       */
      fatal: (entry) => this.fatal({
        scope,
        ...entry
      })
    });
  }
  async addEntryInternal(entry, isVerbose) {
    try {
      await this.addEntry(entry, isVerbose);
    } catch (error) {
      this.error({
        scope: AbstractLoggerScope,
        message: "There was an error adding entry to the log",
        data: {
          entry,
          error
        }
      });
    }
  }
  /**
   * Adds a Verbose level log entry. Verbose is the noisiest level, rarely (if ever) enabled for a production app.
   * @param entry The Log entry
   */
  async verbose(entry) {
    await this.addEntryInternal({
      ...entry,
      level: LogLevel.Verbose
    }, true);
  }
  /**
   * Adds a Debug level log entry. Debug is used for internal system events that are not necessarily observable from the outside, but useful when determining how something happened.
   * @param entry  The Log entry
   */
  async debug(entry) {
    await this.addEntryInternal({
      ...entry,
      level: LogLevel.Debug
    });
  }
  /**
   * Adds an Information level log entry. Information events describe things happening in the system that correspond to its responsibilities and functions. Generally these are the observable actions the system can perform.
   * @param entry  The Log entry
   */
  async information(entry) {
    await this.addEntryInternal({
      ...entry,
      level: LogLevel.Information
    });
  }
  /**
   * Adds a Warning level log entry. When service is degraded, endangered, or may be behaving outside of its expected parameters, Warning level events are used.
   * @param entry  The Log entry
   */
  async warning(entry) {
    await this.addEntryInternal({
      ...entry,
      level: LogLevel.Warning
    });
  }
  /**
   * Adds an Error level log entry. When functionality is unavailable or expectations broken, an Error event is used.
   * @param entry  The Log entry
   */
  async error(entry) {
    try {
      await this.addEntry({
        ...entry,
        level: LogLevel.Error
      });
    } catch (error) {
      await this.fatal({
        scope: AbstractLoggerScope,
        message: "There was an error persisting an Error event in the log and therefore the event was elevated to Fatal level.",
        data: {
          originalEntry: entry,
          error
        }
      });
    }
  }
  /**
   * Adds a Fatal level log entry. The most critical level, Fatal events demand immediate attention.
   * @param entry  The Log entry
   */
  async fatal(entry) {
    await this.addEntry({
      ...entry,
      level: LogLevel.Fatal
    });
  }
  /**
   * Returns an object that contains shortcuts to the original logger that contains the provided scope.
   * usage example:
   * ```ts
   *  const scopedLogger = myLogger.withScope("myLogScope")
   *  scopedLogger.information({message: "foo"}) // will add an information entry with the provided scope
   * ```
   */
};

// ../../node_modules/@sensenet/client-utils/dist/esm/logger/colors.js
var colors = {
  aliceblue: "aliceblue",
  antiquewhite: "antiquewhite",
  aqua: "aqua",
  aquamarine: "aquamarine",
  azure: "azure",
  beige: "beige",
  bisque: "bisque",
  black: "black",
  blanchedalmond: "blanchedalmond",
  blue: "blue",
  blueviolet: "blueviolet",
  brown: "brown",
  burlywood: "burlywood",
  cadetblue: "cadetblue",
  chartreuse: "chartreuse",
  chocolate: "chocolate",
  coral: "coral",
  cornflowerblue: "cornflowerblue",
  cornsilk: "cornsilk",
  crimson: "crimson",
  cyan: "cyan",
  darkblue: "darkblue",
  darkcyan: "darkcyan",
  darkgoldenrod: "darkgoldenrod",
  darkgray: "darkgray",
  darkgreen: "darkgreen",
  darkgrey: "darkgrey",
  darkkhaki: "darkkhaki",
  darkmagenta: "darkmagenta",
  darkolivegreen: "darkolivegreen",
  darkorange: "darkorange",
  darkorchid: "darkorchid",
  darkred: "darkred",
  darksalmon: "darksalmon",
  darkseagreen: "darkseagreen",
  darkslateblue: "darkslateblue",
  darkslategray: "darkslategray",
  darkslategrey: "darkslategrey",
  darkturquoise: "darkturquoise",
  darkviolet: "darkviolet",
  deeppink: "deeppink",
  deepskyblue: "deepskyblue",
  dimgray: "dimgray",
  dimgrey: "dimgrey",
  dodgerblue: "dodgerblue",
  firebrick: "firebrick",
  floralwhite: "floralwhite",
  forestgreen: "forestgreen",
  fuchsia: "fuchsia",
  gainsboro: "gainsboro",
  ghostwhite: "ghostwhite",
  gold: "gold",
  goldenrod: "goldenrod",
  gray: "gray",
  green: "green",
  greenyellow: "greenyellow",
  grey: "grey",
  honeydew: "honeydew",
  hotpink: "hotpink",
  indianred: "indianred",
  indigo: "indigo",
  ivory: "ivory",
  khaki: "khaki",
  lavender: "lavender",
  lavenderblush: "lavenderblush",
  lawngreen: "lawngreen",
  lemonchiffon: "lemonchiffon",
  lightblue: "lightblue",
  lightcoral: "lightcoral",
  lightcyan: "lightcyan",
  lightgoldenrodyellow: "lightgoldenrodyellow",
  lightgray: "lightgray",
  lightgreen: "lightgreen",
  lightgrey: "lightgrey",
  lightpink: "lightpink",
  lightsalmon: "lightsalmon",
  lightseagreen: "lightseagreen",
  lightskyblue: "lightskyblue",
  lightslategray: "lightslategray",
  lightslategrey: "lightslategrey",
  lightsteelblue: "lightsteelblue",
  lightyellow: "lightyellow",
  lime: "lime",
  limegreen: "limegreen",
  linen: "linen",
  magenta: "magenta",
  maroon: "maroon",
  mediumaquamarine: "mediumaquamarine",
  mediumblue: "mediumblue",
  mediumorchid: "mediumorchid",
  mediumpurple: "mediumpurple",
  mediumseagreen: "mediumseagreen",
  mediumslateblue: "mediumslateblue",
  mediumspringgreen: "mediumspringgreen",
  mediumturquoise: "mediumturquoise",
  mediumvioletred: "mediumvioletred",
  midnightblue: "midnightblue",
  mintcream: "mintcream",
  mistyrose: "mistyrose",
  moccasin: "moccasin",
  navajowhite: "navajowhite",
  navy: "navy",
  oldlace: "oldlace",
  olive: "olive",
  olivedrab: "olivedrab",
  orange: "orange",
  orangered: "orangered",
  orchid: "orchid",
  palegoldenrod: "palegoldenrod",
  palegreen: "palegreen",
  paleturquoise: "paleturquoise",
  palevioletred: "palevioletred",
  papayawhip: "papayawhip",
  peachpuff: "peachpuff",
  peru: "peru",
  pink: "pink",
  plum: "plum",
  powderblue: "powderblue",
  purple: "purple",
  red: "red",
  rosybrown: "rosybrown",
  royalblue: "royalblue",
  saddlebrown: "saddlebrown",
  salmon: "salmon",
  sandybrown: "sandybrown",
  seagreen: "seagreen",
  seashell: "seashell",
  sienna: "sienna",
  silver: "silver",
  skyblue: "skyblue",
  slateblue: "slateblue",
  slategray: "slategray",
  slategrey: "slategrey",
  snow: "snow",
  springgreen: "springgreen",
  steelblue: "steelblue",
  tan: "tan",
  teal: "teal",
  thistle: "thistle",
  tomato: "tomato",
  turquoise: "turquoise",
  violet: "violet",
  wheat: "wheat",
  white: "white",
  whitesmoke: "whitesmoke",
  yellow: "yellow",
  yellowgreen: "yellowgreen"
};

// ../../node_modules/@sensenet/client-utils/dist/esm/logger/console-logger.js
var _dec;
var _class;
var _dec2;
var _class2;
var Reset = "\x1B[0m";
var FgRed = "\x1B[31m";
var FgGreen = "\x1B[32m";
var FgYellow = "\x1B[33m";
var FgBlue = "\x1B[34m";
var getLevelColor = function(level) {
  let isBrowser = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let color;
  switch (level) {
    case LogLevel.Verbose:
      color = isBrowser ? colors.darkblue : FgBlue;
      break;
    case LogLevel.Debug:
      color = isBrowser ? colors.darkblue : FgBlue;
      break;
    case LogLevel.Information:
      color = isBrowser ? colors.darkgreen : FgGreen;
      break;
    case LogLevel.Warning:
      color = isBrowser ? colors.darkorange : FgYellow;
      break;
    case LogLevel.Error:
      color = isBrowser ? colors.darkred : FgRed;
      break;
    default:
      color = isBrowser ? colors.darkred : FgRed;
      break;
  }
  return color;
};
var defaultFormatter = (entry, isVerbose) => {
  const fontColor = getLevelColor(entry.level);
  const formattedEntry = [`${fontColor}%s${Reset}`, entry.scope, entry.message];
  return entry.data && isVerbose ? [...formattedEntry, entry.data] : formattedEntry;
};
var browserFormatter = (_ref) => {
  let {
    level,
    message,
    data,
    scope
  } = _ref;
  if (!scope) {
    return data ? [message, data] : [message];
  }
  const fontColor = getLevelColor(level, true);
  const formattedEntry = [`%c[${scope}]:`, `color: ${fontColor}`, message];
  return data ? [...formattedEntry, data] : formattedEntry;
};
var ConsoleLogger = (_dec = Injectable({
  lifetime: "scoped"
}), _dec(_class = class ConsoleLogger2 extends AbstractLogger {
  async addEntry(entry) {
    let isVerbose = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const data = defaultFormatter(entry, isVerbose);
    console.log(...data);
  }
}) || _class);
var BrowserConsoleLogger = (_dec2 = Injectable({
  lifetime: "scoped"
}), _dec2(_class2 = class BrowserConsoleLogger2 extends AbstractLogger {
  async addEntry(entry) {
    const data = browserFormatter(entry);
    console.log(...data);
  }
}) || _class2);

// ../../node_modules/@sensenet/client-utils/dist/esm/logger/log-entries.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Verbose"] = 0] = "Verbose";
  LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
  LogLevel2[LogLevel2["Information"] = 2] = "Information";
  LogLevel2[LogLevel2["Warning"] = 3] = "Warning";
  LogLevel2[LogLevel2["Error"] = 4] = "Error";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
})(LogLevel || (LogLevel = {}));

// ../../node_modules/@sensenet/client-utils/dist/esm/logger/logger-collection.js
var _dec3;
var _class3;
var LoggerCollection = (_dec3 = Injectable({
  lifetime: "singleton"
}), _dec3(_class3 = class LoggerCollection2 extends AbstractLogger {
  constructor() {
    super(...arguments);
    this.loggers = [];
  }
  async addEntry(entry) {
    const promises = this.loggers.map((l) => l.addEntry(entry));
    await Promise.all(promises);
  }
  attachLogger() {
    this.loggers.push(...arguments);
  }
}) || _class3);

// ../../node_modules/@sensenet/client-utils/dist/esm/value-observer.js
var ValueObserver = class {
  /**
   * Disposes the ValueObserver instance. Unsubscribes from the observable
   */
  dispose() {
    this.observable.unsubscribe(this);
  }
  /**
   * @constructs ValueObserver<T> the ValueObserver instance
   */
  constructor(observable, callback) {
    this.observable = observable;
    this.callback = callback;
  }
};

// ../../node_modules/@sensenet/client-utils/dist/esm/observable-value.js
var ObservableValue = class {
  /**
   * Disposes the ObservableValue object, removes all observers
   */
  dispose() {
    this.observers.clear();
  }
  /**
   * Subscribes to a value changes
   * @param {ValueChangeCallback<T>} callback The callback method that will be called on each change
   * @param {boolean} getLast Will call the callback with the last known value right after subscription
   * @returns {ValueObserver<T>} The ValueObserver instance
   */
  subscribe(callback) {
    let getLast = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const observer = new ValueObserver(this, callback);
    this.observers.add(observer);
    if (getLast) {
      callback(this.currentValue);
    }
    return observer;
  }
  /**
   * The observer will unsubscribe from the Observable
   * @param {ValueObserver<T>} observer The ValueObserver instance
   * @returns if unsubscribing was successfull
   */
  unsubscribe(observer) {
    return this.observers.delete(observer);
  }
  /**
   * Gets the current Value
   * @returns {T} The current value
   */
  getValue() {
    return this.currentValue;
  }
  /**
   * Sets a new value and notifies the observers.
   * @param {T} newValue The new value to be set
   */
  setValue(newValue) {
    if (this.currentValue !== newValue) {
      this.currentValue = newValue;
      for (const subscription of this.observers) {
        subscription.callback(newValue);
      }
    }
  }
  /**
   * Gets the observers
   * @returns {ReadonlyArray<ValueObserver<T>>} The subscribed observers
   */
  getObservers() {
    return Array.from(this.observers);
  }
  /**
   * @constructs The ObservableValue object
   * @param {T} initialValue Optional initial value
   */
  constructor(initialValue) {
    this.observers = /* @__PURE__ */ new Set();
    this.currentValue = void 0;
    if (initialValue) {
      this.currentValue = initialValue;
    }
  }
};

// ../../node_modules/@sensenet/client-utils/dist/esm/logger/notification-service.js
var _dec4;
var _class4;
var NotificationService = (_dec4 = Injectable({
  lifetime: "singleton"
}), _dec4(_class4 = class NotificationService2 {
  constructor() {
    this.activeMessages = new ObservableValue([]);
  }
  add(newMessage) {
    this.activeMessages.setValue([...this.activeMessages.getValue().filter((message) => message.level !== newMessage.level), newMessage]);
  }
  dismiss(oldItem) {
    this.activeMessages.setValue([...this.activeMessages.getValue()].filter((message) => message && JSON.stringify(message) !== JSON.stringify(oldItem)));
  }
}) || _class4);

// ../../node_modules/@sensenet/client-utils/dist/esm/logger/notification-logger.js
var _dec5;
var _dec22;
var _dec32;
var _class5;
var NotificationLogger = (_dec5 = Injectable({
  lifetime: "scoped"
}), _dec22 = Reflect.metadata("design:type", Function), _dec32 = Reflect.metadata("design:paramtypes", [typeof NotificationService === "undefined" ? Object : NotificationService]), _dec5(_class5 = _dec22(_class5 = _dec32(_class5 = class NotificationLogger2 extends AbstractLogger {
  useLogLevels(loglevels) {
    this.logLevels = loglevels;
  }
  async addEntry(entry) {
    if (this.logLevels.includes(LogLevel[entry.level])) {
      this.notificationService.add(entry);
    }
  }
  constructor(notificationService) {
    super();
    this.notificationService = notificationService;
    this.logLevels = ["Information", "Warning", "Error", "Fatal"];
  }
}) || _class5) || _class5) || _class5);

// ../../node_modules/@sensenet/client-utils/dist/esm/filter-async.js
var filterAsync = async (values, callbackFn) => {
  const returns = [];
  for (const value of values) {
    ;
    await callbackFn(value) && returns.push(value);
  }
  return returns;
};
Array.prototype.filterAsync = function(callbackFn) {
  return filterAsync(this, callbackFn);
};

// ../../node_modules/@sensenet/client-utils/dist/esm/path-helper.js
var PathHelper = class {
  /**
   * Trims the slash characters from the beginning and from the end of the path to avoid duplicated slashes
   * @param {string} path The source path that should be trimmed
   */
  static trimSlashes(path) {
    while (path.endsWith("/")) {
      path = path.substring(0, path.length - 1);
    }
    while (path.startsWith("/")) {
      path = path.substring(1, path.length);
    }
    return path;
  }
  /**
   * Check if url contain https.
   * @param {string} path The source path that should be trimmed
   * @returns {string}  If path does not contain <schema> it will attach https://{path}.
   */
  static ensureDefaultSchema(path) {
    const validUrl = new RegExp("^[a-zA-Z]+[:][/]{1}");
    if (validUrl.test(path)) {
      return path;
    }
    return `https://${path}`;
  }
  /**
   * Splits a full path into path segments,
   * e.g.: /Root/Example('Content1') will be ["Root", "Example", "('Content1')"]
   * @param path The path to be splitted
   */
  static getSegments(path) {
    if (!path || path.startsWith("content") || path.startsWith("/content")) {
      return [];
    }
    const splitted = path.split("/").filter(Boolean);
    const lastItem = splitted.pop();
    if (!lastItem) {
      throw new Error(`Couldn't get the segments for ${path}`);
    }
    const matches = lastItem.match(/(\('.+'\)$)/g);
    if (!matches) {
      return [...splitted, lastItem];
    }
    const lastSegmentBeforeColumn = lastItem.split(matches[0])[0];
    return [...splitted, lastSegmentBeforeColumn, ...matches];
  }
  /**
   * Checks if a specific segment is an Item segment or not (like "('Content1')")
   * @param segment The segment to be examined
   */
  static isItemSegment(segment) {
    return RegExp(/\('.+'\)$/).test(segment);
  }
  /**
   * Method that tells if a path is an item path or an item reference path (e.g. contains an Item segment).
   * @param {string} path Path that you want to test.
   * @returns {boolean} Returns if the given path is a path of a Content or not.
   */
  static isItemPath(path) {
    const segments = this.getSegments(path);
    const itemSegment = segments.find((s) => this.isItemSegment(s));
    return itemSegment && itemSegment.length ? true : false;
  }
  /**
   * Returns the full path for a content based on its Id or Path
   * @param {string | number} idOrPath the Id Or Path of the content
   * @returns A full Id or Path-based url of the content (e.g.  *'/content(1)'* or *'/Root/Example/('Content')'*)
   */
  static getContentUrl(idOrPath) {
    const parsed = parseInt(idOrPath, 10);
    if (isNaN(parsed)) {
      return this.getContentUrlByPath(idOrPath.toString());
    } else {
      return this.getContentUrlbyId(parsed);
    }
  }
  /**
   * Method that gets the URL that refers to a single item in the Sense/Net Content Repository
   * @param {string} path Path that you want to format.
   * @returns {string} Path in entity format e.g. /workspaces('project') from /workspaces/project
   */
  static getContentUrlByPath(path) {
    if (!path) {
      throw Error("Path is empty");
    }
    const segments = this.getSegments(path);
    if (!this.isItemPath(path)) {
      segments[segments.length - 1] = `('${segments[segments.length - 1]}')`;
    }
    return segments.join("/");
  }
  /**
   * Method that gets the URL that refers to a single item in the Sense/Net Content Repository by its Id
   * @param id {number} Id of the Content.
   * @returns {string} e.g. /content(123)
   */
  static getContentUrlbyId(id) {
    return `content(${id})`;
  }
  /**
   * Method that allows to join paths without multiple or missing slashes
   * @param args The list of the paths to join
   */
  static joinPaths() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return args.map(this.trimSlashes).join("/");
  }
  /**
   * Checks if the ancestorPath is really the ancestor of the descendantPath
   * @param {string} ancestorPath the ancestor path
   * @param {string} descendantPath the descendant path
   * @returns {boolean} if the provided path is the ancestor of the descendant
   */
  static isAncestorOf(ancestorPath, descendantPath) {
    const trimmedDescendantPath = this.trimSlashes(descendantPath);
    const trimmedAncestorPath = this.trimSlashes(ancestorPath);
    return trimmedDescendantPath.indexOf(`${this.joinPaths(trimmedAncestorPath)}/`) === 0;
  }
  static isInSubTree(currentPath, treeRoot) {
    const regexp = new RegExp(`^${treeRoot}(/|$)`);
    return regexp.test(currentPath);
  }
  /**
   * Returns the parent path from a specified path.
   * e.g. "/Root/Example/Content" will return "/Root/Example"
   *
   * "Root" will always return "Root"
   * @param path The content path
   */
  static getParentPath(path) {
    const segments = this.getSegments(path);
    if (segments.length > 1) {
      segments.pop();
    }
    return segments.join("/");
  }
};

// ../../node_modules/@sensenet/client-utils/dist/esm/retrier-options.js
var RetrierOptions = class _RetrierOptions {
  constructor() {
    this.retries = _RetrierOptions.RETRIES_DEFAULT;
    this.retryIntervalMs = void 0;
    this.timeoutMsValue = void 0;
    this.onTry = void 0;
    this.onSuccess = void 0;
    this.onFail = void 0;
  }
  /**
   * How many times should retry the operation
   */
  get Retries() {
    return this.retries;
  }
  set Retries(v) {
    this.retries = v;
  }
  /**
   * The default interval between retries
   */
  /**
   * The interval between tries in milliseconds
   */
  get RetryIntervalMs() {
    return this.retryIntervalMs !== void 0 ? this.retryIntervalMs : _RetrierOptions.RETRY_INTERVAL_MS_DEFAULT;
  }
  set RetryIntervalMs(v) {
    this.retryIntervalMs = v;
  }
  /**
   * The default timeout in millisecs
   */
  /**
   * The Timeout interval in milliseconds
   */
  get timeoutMs() {
    return this.timeoutMsValue !== void 0 ? this.timeoutMsValue : _RetrierOptions.TIMEOUT_MS_DEFAULT;
  }
  set timeoutMs(v) {
    this.timeoutMsValue = v;
  }
  /**
   * Optional callback, triggered right before each try
   */
};
RetrierOptions.RETRIES_DEFAULT = 10;
RetrierOptions.RETRY_INTERVAL_MS_DEFAULT = 10;
RetrierOptions.TIMEOUT_MS_DEFAULT = 1e3;

// ../../node_modules/@sensenet/client-utils/dist/esm/trace.js
var Trace = class {
  static getMethodTrace(object, methodName) {
    const objectTrace = this.objectTraces.get(object);
    return objectTrace.methodMappings.get(methodName);
  }
  static traceStart(methodTrace, args) {
    const startDateTime = /* @__PURE__ */ new Date();
    const traceValue = {
      methodArguments: args,
      startDateTime
    };
    methodTrace.callObservable.setValue(traceValue);
    return traceValue;
  }
  static traceFinished(methodTrace, args, callTrace, returned) {
    const finishedTrace = {
      methodArguments: args,
      startDateTime: callTrace.startDateTime,
      finishedDateTime: /* @__PURE__ */ new Date(),
      returned
    };
    methodTrace.finishedObservable.setValue(finishedTrace);
  }
  static traceError(methodTrace, args, callTrace, error) {
    const errorTrace = {
      methodArguments: args,
      startDateTime: callTrace.startDateTime,
      errorDateTime: /* @__PURE__ */ new Date(),
      error
    };
    methodTrace.errorObservable.setValue(errorTrace);
    return errorTrace;
  }
  static callMethod(object, methodName, args) {
    const methodTrace = this.getMethodTrace(object, methodName);
    const start = this.traceStart(methodTrace, args);
    try {
      const returned = methodTrace.originalMethod.call(object, ...args);
      this.traceFinished(methodTrace, args, start, returned);
      return returned;
    } catch (error) {
      this.traceError(methodTrace, args, start, error);
      throw error;
    }
  }
  static async callMethodAsync(object, methodName, args) {
    const methodTrace = this.getMethodTrace(object, methodName);
    const start = this.traceStart(methodTrace, args);
    try {
      const returned = await methodTrace.originalMethod.call(object, ...args);
      this.traceFinished(methodTrace, args, start, returned);
      return returned;
    } catch (error) {
      this.traceError(methodTrace, args, start, error);
      throw error;
    }
  }
  /**
   * Creates an observer that will be observe method calls, finishes and errors
   * @param options The options object for the trace
   */
  static method(options) {
    var _this = this;
    if (!this.objectTraces.has(options.object)) {
      this.objectTraces.set(options.object, {
        methodMappings: /* @__PURE__ */ new Map()
      });
    }
    if (!options.object[options.methodName].isTraced) {
      const overriddenMethod = options.isAsync ? function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _this.callMethodAsync(options.object, options.methodName, args);
      } : function() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return _this.callMethod(options.object, options.methodName, args);
      };
      Object.defineProperty(overriddenMethod, "name", {
        value: options.methodName
      });
      Object.defineProperty(overriddenMethod, "isTraced", {
        value: options.methodName
      });
      options.object[options.methodName] = overriddenMethod;
    }
    const objectTrace = this.objectTraces.get(options.object);
    if (!objectTrace.methodMappings.has(options.methodName)) {
      objectTrace.methodMappings.set(options.methodName, {
        originalMethod: options.method,
        callObservable: new ObservableValue(),
        finishedObservable: new ObservableValue(),
        errorObservable: new ObservableValue()
      });
    }
    const methodTrace = objectTrace.methodMappings.get(options.methodName);
    const callbacks = [options.onCalled && methodTrace.callObservable.subscribe(options.onCalled), options.onFinished && methodTrace.finishedObservable.subscribe(options.onFinished), options.onError && methodTrace.errorObservable.subscribe(options.onError)];
    return {
      dispose: () => callbacks.forEach((c) => c && c.dispose())
    };
  }
};
Trace.objectTraces = /* @__PURE__ */ new Map();

// ../../node_modules/@sensenet/client-core/dist/esm/Repository/ConstantContent.js
var ConstantContent = class {
};
ConstantContent.VISITOR_USER = {
  Id: 6,
  DisplayName: "Visitor",
  Domain: "BuiltIn",
  Name: "Visitor",
  Path: "/Root/IMS/BuiltIn/Portal/Visitor",
  LoginName: "Visitor",
  Type: "User"
};
ConstantContent.PORTAL_ROOT = {
  Id: 2,
  Path: "/Root",
  Name: "Root",
  DisplayName: "Root",
  Type: "PortalRoot"
};
ConstantContent.EMPTY_CONTENT = {
  Id: 0,
  Path: "",
  Name: "",
  DisplayName: "",
  Type: ""
};

// ../../node_modules/@sensenet/client-core/dist/esm/Authentication/LoginState.js
var LoginState;
(function(LoginState2) {
  LoginState2["Pending"] = "Pending";
  LoginState2["Unauthenticated"] = "Unauthenticated";
  LoginState2["Authenticated"] = "Authenticated";
  LoginState2["Unknown"] = "Unknown";
})(LoginState || (LoginState = {}));

// ../../node_modules/@sensenet/client-core/dist/esm/Authentication/BypassAuthentication.js
var BypassAuthentication = class {
  constructor() {
    this.state = new ObservableValue(LoginState.Unknown);
    this.currentUser = new ObservableValue(ConstantContent.VISITOR_USER);
  }
  /**
   * Checks for update if neccessary. For BypassAuthentication always resolves immedietly with false
   */
  async checkForUpdate() {
    return false;
  }
  /**
   * Login method - not available for BypassAuthentication
   */
  async login() {
    throw new Error("Not allowed when authentication is bypassed.");
  }
  /**
   * logout method - not available for BypassAuthentication
   */
  async logout() {
    throw new Error("Not allowed when authentication is bypassed.");
  }
  /**
   * Current user observable property - Will publish the Visitor user for BypassAuthentication
   */
  /**
   * Disposes the service
   */
  dispose() {
  }
};

// ../../node_modules/@sensenet/client-core/dist/esm/Authentication/FormsAuthenticationService.js
var import_semaphore_async_await = __toESM(require_dist());

// ../../node_modules/@sensenet/client-core/dist/esm/Repository/ODataUrlBuilder.js
var ODataUrlBuilder = class {
  /**
   * List of a valid OData parameters
   */
  static combineODataFieldParameters() {
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }
    const filtered = params.filter(Boolean);
    const flatten = filtered.reduce((previousValue, currentValue) => previousValue.concat(currentValue), []);
    return [...new Set(flatten)];
  }
  /**
   * Method to build proper parameter string to OData requests based on the given repository configuration and option Object.
   *
   * Checks whether a given parameter is standard OData param or not and based on this information this params get the '$' sign.
   * @param {RepositoryConfiguration} config Represents the current Repository configuration for default select, expand, etc... options
   * @param {ODataParams} options Represents an ODataOptions object. Holds the possible url parameters as properties.
   * @returns {string} String with the url params in the correct format e.g. '$select=DisplayName,Index'&$top=2&metadata=no'.
   */
  static buildUrlParamString(config, options) {
    var _oDataParams$metadata, _oDataParams$inlineco, _oDataParams$expand, _oDataParams$top, _oDataParams$enableau, _oDataParams$enableli;
    const oDataParams = {
      ...options
    };
    if (config.requiredSelect === "all" || config.defaultSelect === "all" || (oDataParams === null || oDataParams === void 0 ? void 0 : oDataParams.select) === "all") {
      oDataParams.select = void 0;
    } else {
      var _oDataParams$select;
      oDataParams.select = this.combineODataFieldParameters(config.requiredSelect, (_oDataParams$select = oDataParams.select) !== null && _oDataParams$select !== void 0 ? _oDataParams$select : config.defaultSelect);
    }
    oDataParams.metadata = (_oDataParams$metadata = oDataParams.metadata) !== null && _oDataParams$metadata !== void 0 ? _oDataParams$metadata : config.defaultMetadata;
    oDataParams.inlinecount = (_oDataParams$inlineco = oDataParams.inlinecount) !== null && _oDataParams$inlineco !== void 0 ? _oDataParams$inlineco : config.defaultInlineCount;
    oDataParams.expand = (_oDataParams$expand = oDataParams.expand) !== null && _oDataParams$expand !== void 0 ? _oDataParams$expand : config.defaultExpand;
    oDataParams.top = (_oDataParams$top = oDataParams.top) !== null && _oDataParams$top !== void 0 ? _oDataParams$top : config.defaultTop;
    oDataParams.enableautofilters = (_oDataParams$enableau = oDataParams.enableautofilters) !== null && _oDataParams$enableau !== void 0 ? _oDataParams$enableau : config.defaultEnableAutofilters;
    oDataParams.enablelifespanfilter = (_oDataParams$enableli = oDataParams.enablelifespanfilter) !== null && _oDataParams$enableli !== void 0 ? _oDataParams$enableli : config.defaultEnableLifespanfilter;
    const segments = [];
    for (const key in oDataParams) {
      const name = this.ODATA_PARAMS.includes(key) ? `$${key}` : key;
      const plainValue = oDataParams[key];
      let parsedValue = plainValue;
      if (plainValue instanceof Array && plainValue.length) {
        parsedValue = plainValue.map((v) => {
          var _v$join, _v$join2;
          return (_v$join = (_v$join2 = v.join) === null || _v$join2 === void 0 ? void 0 : _v$join2.call(v, " ")) !== null && _v$join !== void 0 ? _v$join : v;
        }).join(",");
      }
      if (name && parsedValue && parsedValue.toString().length) {
        segments.push({
          name,
          value: parsedValue
        });
      }
    }
    return segments.map((s) => `${s.name}=${encodeURIComponent(s.value)}`).join("&");
  }
};
ODataUrlBuilder.ODATA_PARAMS = ["select", "expand", "orderby", "top", "skip", "filter", "format", "inlinecount"];

// ../../node_modules/@sensenet/client-core/dist/esm/Schemas/SchemaStore.js
var SchemaStore = class {
  constructor() {
    this.schemas = new ObservableValue([]);
    this.byNameSchemaCache = /* @__PURE__ */ new Map();
  }
  subscribeToSchemas(callback) {
    return this.schemas.subscribe(callback);
  }
  /**
   * Updates the schema information in the store and inv
   */
  setSchemas(newSchemas) {
    this.byNameSchemaCache.clear();
    this.schemas.setValue(newSchemas);
  }
  mergeFieldSettings(currentFieldSettings, parentFieldSettings) {
    const currentFieldSettingsMap = /* @__PURE__ */ new Map();
    currentFieldSettings.forEach((s) => currentFieldSettingsMap.set(s.Name, s));
    const parentFieldSettingsMap = /* @__PURE__ */ new Map();
    parentFieldSettings.forEach((s) => parentFieldSettingsMap.set(s.Name, s));
    const keys = /* @__PURE__ */ new Set([...currentFieldSettingsMap.keys(), ...parentFieldSettingsMap.keys()]);
    return Array.from(keys).map((key) => {
      return {
        ...parentFieldSettingsMap.get(key),
        ...currentFieldSettingsMap.get(key)
      };
    });
  }
  /**
   * Returns the Content Type Schema for the provided content type name
   * @param {string} contentTypeName The name of the content type
   */
  getSchemaByName(contentTypeName) {
    if (this.byNameSchemaCache.has(contentTypeName)) {
      return Object.assign({}, this.byNameSchemaCache.get(contentTypeName));
    }
    const schema = this.schemas.getValue().find((s) => s.ContentTypeName === contentTypeName);
    if (!schema) {
      return this.getSchemaByName("GenericContent");
    }
    const parentSchema = schema.ParentTypeName && this.getSchemaByName(schema.ParentTypeName);
    if (parentSchema) {
      schema.FieldSettings = this.mergeFieldSettings(schema.FieldSettings, parentSchema.FieldSettings);
    }
    this.byNameSchemaCache.set(contentTypeName, schema);
    return schema;
  }
  /**
   * Returns the Field Type for the provided content field name
   * @param {string} fieldName The name of field you search for
   */
  getFieldTypeByName(fieldName) {
    const schemasCopy = [...this.schemas.getValue()];
    return schemasCopy.reduce((_, schema) => {
      var _schema$FieldSettings;
      const fieldType = (_schema$FieldSettings = schema.FieldSettings.find((fieldSetting) => fieldSetting.Name === fieldName)) === null || _schema$FieldSettings === void 0 ? void 0 : _schema$FieldSettings.Type;
      if (fieldType) {
        schemasCopy.length = 0;
      }
      return fieldType;
    }, void 0);
  }
  /**
   * Returns a boolean value that indicates if the specified content is an instance or descendant of a given content type
   * @param content The given content to check
   * @param contentTypeName The name of content type
   */
  isContentFromType(content, contentTypeName) {
    if (!content) {
      return false;
    } else if (content.Type === contentTypeName) {
      return true;
    }
    let currentSchema = this.getSchemaByName(content.Type);
    do {
      if (currentSchema.ContentTypeName === contentTypeName) {
        return true;
      }
      currentSchema = this.getSchemaByName(currentSchema.ParentTypeName || "");
    } while (currentSchema.ContentTypeName && currentSchema.ContentTypeName !== "GenericContent");
    return contentTypeName === "GenericContent";
  }
  /**
   * Returns if a given content type is a descendant of an another content type
   * @param child The child content name
   * @param parent The parent content name
   */
  schemaIsDescendantOf(child, parent) {
    let currentSchema = this.getSchemaByName(child);
    do {
      if (currentSchema.ContentTypeName === parent) {
        return true;
      }
      currentSchema = this.getSchemaByName(currentSchema.ParentTypeName || "");
    } while (currentSchema.ContentTypeName && currentSchema.ContentTypeName !== "GenericContent");
    return parent === "GenericContent";
  }
  /**
   * Returns a list of the content types existing on schema
   */
  getTypesFromSchema() {
    const schemasCopy = [...this.schemas.getValue()];
    const contentTypes = schemasCopy.map((schema) => schema.ContentTypeName.toString());
    return contentTypes;
  }
};

// ../../node_modules/@sensenet/client-core/dist/esm/Repository/AllowedChildTypes.js
var AllowedChildTypes = class {
  add(idOrPath, contentTypes) {
    return this.repository.executeAction({
      idOrPath,
      name: "AddAllowedChildTypes",
      method: "POST",
      body: {
        contentTypes
      }
    });
  }
  update(idOrPath, contentTypes) {
    return this.repository.patch({
      idOrPath,
      content: {
        AllowedChildTypes: contentTypes
      }
    });
  }
  remove(idOrPath, contentTypes) {
    return this.repository.executeAction({
      idOrPath,
      name: "RemoveAllowedChildTypes",
      method: "POST",
      body: {
        contentTypes
      }
    });
  }
  getFromCTD(idOrPath) {
    return this.repository.executeAction({
      idOrPath,
      name: "GetAllowedChildTypesFromCTD",
      method: "GET",
      body: {
        select: ["Name", "DisplayName", "Icon"]
      }
    });
  }
  listEmpty(idOrPath) {
    return this.repository.executeAction({
      idOrPath,
      name: "CheckAllowedChildTypesOfFolders",
      method: "GET"
    });
  }
  /**
   * Retrieves an aggregated list of content types the user can create as children below the given content
   * @param {LoadOptions<ContentType>} options
   */
  async get(options) {
    const allowedTypes = {
      d: {
        __count: 0,
        results: []
      }
    };
    await Promise.all([this.getImplicit(options), this.getExplicit(options)]).then((_ref) => {
      let [implicitACTs, explicitACTs] = _ref;
      allowedTypes.d.results = implicitACTs.d ? implicitACTs.d.results.filter((ct) => !explicitACTs.d.results.find((contenttype) => ct.Name === contenttype.Name)).concat(explicitACTs.d.results) : [];
      allowedTypes.d.__count = allowedTypes.d.results.length;
    });
    return allowedTypes;
  }
  /**
   * Retrieves a list of content types the user can create as children below the given content (allowed on the content)
   * @param {LoadOptions<ContentType>} options Options for fetching the AllowedChildTypes
   */
  async getImplicit(options) {
    const contextPath = PathHelper.getContentUrl(options.idOrPath);
    const params = ODataUrlBuilder.buildUrlParamString(this.repository.configuration, options.oDataOptions);
    const path = PathHelper.joinPaths(this.repository.configuration.repositoryUrl, this.repository.configuration.oDataToken, contextPath, "AllowedChildTypes");
    const response = await this.repository.fetch(`${path}?${params}`, {
      credentials: "include",
      method: "GET"
    });
    if (!response.ok) {
      throw await this.repository.getErrorFromResponse(response);
    }
    return await response.json();
  }
  /**
   * Retrieves a list of content types the user can create as children below the given content (allowed in the CTD)
   * @param {LoadOptions<ContentType>} options Options for fetching the AllowedChildTypes
   */
  async getExplicit(options) {
    const contextPath = PathHelper.getContentUrl(options.idOrPath);
    const params = ODataUrlBuilder.buildUrlParamString(this.repository.configuration, options.oDataOptions);
    const path = PathHelper.joinPaths(this.repository.configuration.repositoryUrl, this.repository.configuration.oDataToken, contextPath, "EffectiveAllowedChildTypes");
    const response = await this.repository.fetch(`${path}?${params}`, {
      credentials: "include",
      method: "GET"
    });
    if (!response.ok) {
      throw await this.repository.getErrorFromResponse(response);
    }
    return await response.json();
  }
  constructor(repository) {
    this.repository = repository;
  }
};

// ../../node_modules/@sensenet/client-core/dist/esm/Repository/Preview.js
var Preview = class {
  regenerate(options) {
    var _options$abortControl;
    return this.repository.executeAction({
      name: "RegeneratePreviews",
      idOrPath: options.idOrPath,
      method: "POST",
      body: void 0,
      requestInit: {
        signal: (_options$abortControl = options.abortController) === null || _options$abortControl === void 0 ? void 0 : _options$abortControl.signal
      }
    });
  }
  async available(options) {
    var _options$abortControl2;
    const responseBody = await this.repository.executeAction({
      idOrPath: options.document.idOrPath,
      method: "POST",
      name: "PreviewAvailable",
      oDataOptions: {
        version: options.version
      },
      body: {
        page: options.page
      },
      requestInit: {
        signal: (_options$abortControl2 = options.abortController) === null || _options$abortControl2 === void 0 ? void 0 : _options$abortControl2.signal
      }
    });
    if (responseBody.PreviewAvailable) {
      responseBody.PreviewImageUrl = `${options.document.hostName}${responseBody.PreviewAvailable}`;
      responseBody.ThumbnailImageUrl = `${options.document.hostName}${responseBody.PreviewAvailable.replace("preview", "thumbnail")}`;
      return responseBody;
    }
  }
  async getExistingImages(options) {
    if (options.document.pageCount && options.document.pageCount < -1) {
      throw Error("Preview generation error");
    }
    if (options.document.idOrPath && options.document.hostName && options.document.pageCount) {
      var _options$abortControl3;
      const response = await this.repository.executeAction({
        idOrPath: options.document.idOrPath,
        name: `GetExistingPreviewImages`,
        method: "POST",
        body: {},
        oDataOptions: {
          select: "all",
          expand: "all",
          version: options.version
        },
        requestInit: {
          signal: (_options$abortControl3 = options.abortController) === null || _options$abortControl3 === void 0 ? void 0 : _options$abortControl3.signal
        }
      });
      const availablePreviews = response.map((preview) => {
        if (preview.PreviewAvailable) {
          preview.PreviewImageUrl = `${options.document.hostName}${preview.PreviewAvailable}`;
          preview.ThumbnailImageUrl = `${options.document.hostName}${preview.PreviewAvailable.replace("preview", "thumbnail")}`;
        }
        return preview;
      });
      const allPreviews = [];
      for (let i = 0; i < options.document.pageCount; i++) {
        allPreviews[i] = availablePreviews[i] || {
          Index: i + 1
        };
      }
      return allPreviews;
    } else {
      return [];
    }
  }
  getPageCount(options) {
    var _options$abortControl4;
    return this.repository.executeAction({
      idOrPath: options.idOrPath,
      name: "GetPageCount",
      method: "POST",
      requestInit: {
        signal: (_options$abortControl4 = options.abortController) === null || _options$abortControl4 === void 0 ? void 0 : _options$abortControl4.signal
      }
    });
  }
  check(options) {
    var _options$abortControl5;
    return this.repository.executeAction({
      idOrPath: options.idOrPath,
      name: "CheckPreviews",
      method: "POST",
      body: {
        generateMissing: options.generateMissing
      },
      requestInit: {
        signal: (_options$abortControl5 = options.abortController) === null || _options$abortControl5 === void 0 ? void 0 : _options$abortControl5.signal
      }
    });
  }
  getComments(options) {
    var _options$abortControl6;
    return this.repository.executeAction({
      idOrPath: options.idOrPath,
      name: "GetPreviewComments",
      method: "GET",
      oDataOptions: {
        page: options.page
      },
      requestInit: {
        signal: (_options$abortControl6 = options.abortController) === null || _options$abortControl6 === void 0 ? void 0 : _options$abortControl6.signal
      }
    });
  }
  addComment(options) {
    var _options$abortControl7;
    return this.repository.executeAction({
      idOrPath: options.idOrPath,
      name: "AddPreviewComment",
      method: "POST",
      body: options.comment,
      requestInit: {
        signal: (_options$abortControl7 = options.abortController) === null || _options$abortControl7 === void 0 ? void 0 : _options$abortControl7.signal
      }
    });
  }
  deleteComment(options) {
    var _options$abortControl8;
    return this.repository.executeAction({
      idOrPath: options.idOrPath,
      name: "DeletePreviewComment",
      method: "POST",
      body: {
        id: options.commentId
      },
      requestInit: {
        signal: (_options$abortControl8 = options.abortController) === null || _options$abortControl8 === void 0 ? void 0 : _options$abortControl8.signal
      }
    });
  }
  constructor(repository) {
    this.repository = repository;
  }
};

// ../../node_modules/@sensenet/default-content-types/dist/esm/FieldSettings.js
var FieldVisibility;
(function(FieldVisibility2) {
  FieldVisibility2[FieldVisibility2["Show"] = 0] = "Show";
  FieldVisibility2[FieldVisibility2["Hide"] = 1] = "Hide";
  FieldVisibility2[FieldVisibility2["Advanced"] = 2] = "Advanced";
})(FieldVisibility || (FieldVisibility = {}));
var OutputMethod;
(function(OutputMethod2) {
  OutputMethod2[OutputMethod2["Default"] = 0] = "Default";
  OutputMethod2[OutputMethod2["Raw"] = 1] = "Raw";
  OutputMethod2[OutputMethod2["Text"] = 2] = "Text";
  OutputMethod2[OutputMethod2["Html"] = 3] = "Html";
})(OutputMethod || (OutputMethod = {}));
var DisplayChoice;
(function(DisplayChoice2) {
  DisplayChoice2["DropDown"] = "DropDown";
  DisplayChoice2["RadioButtons"] = "RadioButtons";
  DisplayChoice2["CheckBoxes"] = "CheckBoxes";
})(DisplayChoice || (DisplayChoice = {}));
var DateTimeMode;
(function(DateTimeMode2) {
  DateTimeMode2["None"] = "None";
  DateTimeMode2["Date"] = "Date";
  DateTimeMode2["DateAndTime"] = "DateAndTime";
})(DateTimeMode || (DateTimeMode = {}));
var DateTimePrecision;
(function(DateTimePrecision2) {
  DateTimePrecision2["Millisecond"] = "Millisecond";
  DateTimePrecision2["Second"] = "Second";
  DateTimePrecision2["Minute"] = "Minute";
  DateTimePrecision2["Hour"] = "Hour";
  DateTimePrecision2["Day"] = "Day";
})(DateTimePrecision || (DateTimePrecision = {}));

// ../../node_modules/@sensenet/default-content-types/dist/esm/DefaultSchemas.js
var SchemaStore2 = [{
  ContentTypeName: "ContentType",
  DisplayName: "$Ctd-ContentType,DisplayName",
  Description: "$Ctd-ContentType,Description",
  Icon: "ContentType",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "IntegerFieldSetting",
    Name: "Id",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Id",
    Description: "A unique ID for the Content.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "ParentId",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Id",
    Description: "A unique ID for the Content.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "VersionId",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "Name",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Uri name",
    ReadOnly: false,
    Compulsory: true,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "IntegerFieldSetting",
    Name: "CreatedById",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "ModifiedById",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "Version",
    FieldClassName: "SenseNet.ContentRepository.Fields.VersionField",
    DisplayName: "Version",
    Description: "Latest version number.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Name: "Path",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Path",
    Description: "Content type path.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "IntegerFieldSetting",
    Name: "Depth",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "IsSystemContent",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "System Content",
    Description: "This field is true if content is in a system folder/trash or the content is a system folder/file.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "HandlerName",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Handler Name",
    Description: "Fully Qualified Name.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Name: "ParentTypeName",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Parent Type Name",
    Description: "Name of the parent content type.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Name: "DisplayName",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Name",
    Description: "User friendly name of the content type.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "LongTextFieldSetting",
    Name: "Description",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Description",
    Description: "Longer description of the content type.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Name: "Icon",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Icon",
    Description: "Content type icon.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "BinaryFieldSetting",
    IsText: true,
    Name: "Binary",
    FieldClassName: "SenseNet.ContentRepository.Fields.BinaryField",
    DisplayName: "Binary",
    Description: "The content type definition in XML format.",
    ReadOnly: false,
    Compulsory: false,
    DefaultValue: '<?xml version="1.0" encoding="utf-8"?><ContentType name="MyType" parentType="GenericContent" handler="SenseNet.ContentRepository.GenericContent" xmlns="http://schemas.sensenet.com/SenseNet/ContentRepository/ContentTypeDefinition">  <DisplayName>MyType</DisplayName>  <Description></Description>  <Icon>Content</Icon>  <AllowIncrementalNaming>true</AllowIncrementalNaming>  <AllowedChildTypes>ContentTypeName1,ContentTypeName2</AllowedChildTypes>  <Fields>    <Field name="ShortTextField" type="ShortText">      <DisplayName>ShortTextField</DisplayName>      <Description></Description>      <Configuration>        <MaxLength>100</MaxLength>        <MinLength>0</MinLength>        <Regex>[a-zA-Z0-9]*$</Regex>        <ReadOnly>false</ReadOnly>        <Compulsory>false</Compulsory>        <DefaultValue></DefaultValue>        <VisibleBrowse>Show|Hide|Advanced</VisibleBrowse>        <VisibleEdit>Show|Hide|Advanced</VisibleEdit>        <VisibleNew>Show|Hide|Advanced</VisibleNew>      </Configuration>    </Field>    <Field name="LongTextField" type="LongText">      <DisplayName>LongTextField</DisplayName>      <Description></Description>      <Configuration>        <MaxLength>100</MaxLength>        <MinLength>0</MinLength>        <TextType>LongText|RichText|AdvancedRichText</TextType>        <ReadOnly>false</ReadOnly>        <Compulsory>false</Compulsory>        <DefaultValue></DefaultValue>        <VisibleBrowse>Show|Hide|Advanced</VisibleBrowse>        <VisibleEdit>Show|Hide|Advanced</VisibleEdit>        <VisibleNew>Show|Hide|Advanced</VisibleNew>      </Configuration>    </Field>    <Field name="NumberField" type="Number">      <DisplayName>NumberField</DisplayName>      <Description></Description>      <Configuration>        <MinValue>0</MinValue>        <MaxValue>100.5</MaxValue>        <Digits>2</Digits>        <ReadOnly>false</ReadOnly>        <Compulsory>false</Compulsory>        <DefaultValue></DefaultValue>        <VisibleBrowse>Show|Hide|Advanced</VisibleBrowse>        <VisibleEdit>Show|Hide|Advanced</VisibleEdit>        <VisibleNew>Show|Hide|Advanced</VisibleNew>      </Configuration>    </Field>    <Field name="IntegerField" type="Integer">      <DisplayName>IntegerField</DisplayName>      <Description></Description>      <Configuration>        <MinValue>0</MinValue>        <MaxValue>100</MaxValue>        <ReadOnly>false</ReadOnly>        <Compulsory>false</Compulsory>        <DefaultValue></DefaultValue>        <VisibleBrowse>Show|Hide|Advanced</VisibleBrowse>        <VisibleEdit>Show|Hide|Advanced</VisibleEdit>        <VisibleNew>Show|Hide|Advanced</VisibleNew>      </Configuration>    </Field>    <Field name="BooleanField" type="Boolean">      <DisplayName>BooleanField</DisplayName>      <Description></Description>      <Configuration>        <ReadOnly>false</ReadOnly>        <Compulsory>false</Compulsory>        <DefaultValue></DefaultValue>        <VisibleBrowse>Show|Hide|Advanced</VisibleBrowse>        <VisibleEdit>Show|Hide|Advanced</VisibleEdit>        <VisibleNew>Show|Hide|Advanced</VisibleNew>      </Configuration>    </Field>    <Field name="ChoiceField" type="Choice">      <DisplayName>ChoiceField</DisplayName>      <Description></Description>      <Configuration>        <AllowMultiple>false</AllowMultiple>        <AllowExtraValue>false</AllowExtraValue>        <Options>          <Option selected="true">1</Option>          <Option>2</Option>        </Options>        <ReadOnly>false</ReadOnly>        <Compulsory>false</Compulsory>        <DefaultValue></DefaultValue>        <VisibleBrowse>Show|Hide|Advanced</VisibleBrowse>        <VisibleEdit>Show|Hide|Advanced</VisibleEdit>        <VisibleNew>Show|Hide|Advanced</VisibleNew>      </Configuration>    </Field>    <Field name="DateTimeField" type="DateTime">      <DisplayName>DateTimeField</DisplayName>      <Description></Description>      <Configuration>        <DateTimeMode>DateAndTime</DateTimeMode>        <Precision>Second</Precision>        <ReadOnly>false</ReadOnly>        <Compulsory>false</Compulsory>        <DefaultValue></DefaultValue>        <VisibleBrowse>Show|Hide|Advanced</VisibleBrowse>        <VisibleEdit>Show|Hide|Advanced</VisibleEdit>        <VisibleNew>Show|Hide|Advanced</VisibleNew>      </Configuration>    </Field>    <Field name="ReferenceField" type="Reference">      <DisplayName>ReferenceField</DisplayName>      <Description></Description>      <Configuration>        <AllowMultiple>true</AllowMultiple>        <AllowedTypes>          <Type>Type1</Type>          <Type>Type2</Type>        </AllowedTypes>        <SelectionRoot>          <Path>/Root/Path1</Path>          <Path>/Root/Path2</Path>        </SelectionRoot>        <DefaultValue>/Root/Path1,/Root/Path2</DefaultValue>        <ReadOnly>false</ReadOnly>        <Compulsory>false</Compulsory>        <VisibleBrowse>Show|Hide|Advanced</VisibleBrowse>        <VisibleEdit>Show|Hide|Advanced</VisibleEdit>        <VisibleNew>Show|Hide|Advanced</VisibleNew>      </Configuration>    </Field>    <Field name="BinaryField" type="Binary">      <DisplayName>BinaryField</DisplayName>      <Description></Description>      <Configuration>        <IsText>true</IsText>        <ReadOnly>false</ReadOnly>        <Compulsory>false</Compulsory>        <DefaultValue></DefaultValue>        <VisibleBrowse>Show|Hide|Advanced</VisibleBrowse>        <VisibleEdit>Show|Hide|Advanced</VisibleEdit>        <VisibleNew>Show|Hide|Advanced</VisibleNew>      </Configuration>    </Field>  </Fields></ContentType>',
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ReferenceFieldSetting",
    Name: "CreatedBy",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Created by",
    Description: "Content creator.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "CreationDate",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Creation date",
    Description: "Content creation date.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    Name: "ModifiedBy",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Modified by",
    Description: "Content was last modified by the given user.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "DateTimeFieldSetting",
    Name: "ModificationDate",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Modification date",
    Description: "Content was last modified on the given date.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "EnableLifespan",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Enable Lifespan handling",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.Schema.ContentType"
}, {
  ContentTypeName: "GenericContent",
  DisplayName: "$Ctd-GenericContent,DisplayName",
  Description: "$Ctd-GenericContent,Description",
  Icon: "Content",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "IntegerFieldSetting",
    Name: "Id",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Id",
    Description: "Unique Id for the content.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "ParentId",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Parent Id",
    Description: "Id of the parent content.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "OwnerId",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Owner Id",
    Description: "Id of the owner.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    Name: "Owner",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Owner",
    Description: "Content owner.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "VersionId",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Version Id",
    Description: "Database row Id of current version.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "Icon",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Icon",
    Description: "Icon",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "Name",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Name",
    Description: "Specify a name that will appear in the address bar of the browser.",
    ReadOnly: false,
    Compulsory: true,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show,
    ControlHint: "sn:Name"
  }, {
    Type: "IntegerFieldSetting",
    Name: "CreatedById",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Created By (Id)",
    Description: "Id of creator.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "ModifiedById",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Last Modified By (Id)",
    Description: "Id of last modifier.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "Version",
    FieldClassName: "SenseNet.ContentRepository.Fields.VersionField",
    DisplayName: "Version",
    Description: "Version number.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "Path",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Path",
    Description: "Content path in the repository.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "Depth",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Tree Depth",
    Description: "Content level in the tree. Root level is 0.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "IsSystemContent",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "System Content",
    Description: "This field is true if content is in a system folder/trash or the content is a system folder/file.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "IsFolder",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Folder",
    Description: "This field is true if content can contain other content.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "DisplayName",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Display Name",
    Description: "Content name. You can set any name you prefer without any restrictions.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show,
    ControlHint: "sn:DisplayName"
  }, {
    Type: "LongTextFieldSetting",
    Name: "Description",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Description",
    Description: "Description of the content.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show,
    ControlHint: "sn:RichText"
  }, {
    Type: "NullFieldSetting",
    Name: "Hidden",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Hidden",
    Description: "If checked, content will not show up in navigation.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "Index",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Index",
    Description: "Content order in navigation. Numbers closer to 0 will appear first.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "NullFieldSetting",
    Name: "EnableLifespan",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Enable Lifespan",
    Description: "Specify whether you want to define starting and end date for the validity of this content.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "ValidFrom",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Valid From",
    Description: "This content will appear on the date you set if lifespan handling is enabled for this content.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "ValidTill",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Valid Till",
    Description: "This content will disappear on the date you set if lifespan handling is enabled for this content.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "NullFieldSetting",
    Name: "AllowedChildTypes",
    FieldClassName: "SenseNet.ContentRepository.Fields.AllowedChildTypesField",
    DisplayName: "Allowed child types",
    Description: "You can get and set which content types are explicitly allowed to be created under this content. It is a local setting.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "EffectiveAllowedChildTypes",
    FieldClassName: "SenseNet.ContentRepository.Fields.AllowedChildTypesField",
    DisplayName: "Effective allowed child types",
    Description: "You can get which content types are effective allowed to be created under this content. If there is no local setting, the global setting takes effect.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "0",
      Text: "Inherited",
      Enabled: true,
      Selected: true
    }, {
      Value: "1",
      Text: "None",
      Enabled: true,
      Selected: false
    }, {
      Value: "2",
      Text: "Major only",
      Enabled: true,
      Selected: false
    }, {
      Value: "3",
      Text: "Major and minor",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "VersioningMode",
    FieldClassName: "SenseNet.ContentRepository.Fields.VersioningModeField",
    DisplayName: "Versioning Mode For Current Content",
    Description: "It shows the versioning mode of the current content.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "0",
      Text: "Inherited",
      Enabled: true,
      Selected: true
    }, {
      Value: "1",
      Text: "None",
      Enabled: true,
      Selected: false
    }, {
      Value: "2",
      Text: "Major only",
      Enabled: true,
      Selected: false
    }, {
      Value: "3",
      Text: "Major and minor",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "InheritableVersioningMode",
    FieldClassName: "SenseNet.ContentRepository.Fields.InheritableVersioningModeField",
    DisplayName: "Version history",
    Description: "Specify whether the system should create a new version whenever you create or modify a content below this content.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide,
    ControlHint: "sn:VersioningModeChoice"
  }, {
    Type: "ReferenceFieldSetting",
    Name: "CreatedBy",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Created by",
    Description: "Content creator.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "CreationDate",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Creation date",
    Description: "Content creation date.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    Name: "ModifiedBy",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Modified By",
    Description: "Content was last modified by this user.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "ModificationDate",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Modification Date",
    Description: "Content was last modified on this date.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "0",
      Text: "Inherited",
      Enabled: true,
      Selected: true
    }, {
      Value: "1",
      Text: "Off",
      Enabled: true,
      Selected: false
    }, {
      Value: "2",
      Text: "On",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "ApprovingMode",
    FieldClassName: "SenseNet.ContentRepository.Fields.ApprovingModeField",
    DisplayName: "Content Approval For Current Content",
    Description: "It shows the approval mode of the current content.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "0",
      Text: "Inherited",
      Enabled: true,
      Selected: true
    }, {
      Value: "1",
      Text: "Off",
      Enabled: true,
      Selected: false
    }, {
      Value: "2",
      Text: "On",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "InheritableApprovingMode",
    FieldClassName: "SenseNet.ContentRepository.Fields.InheritableApprovingModeField",
    DisplayName: "Content approval",
    Description: "Specify whether new or changed content below the current one should remain in a draft state until they have been approved.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide,
    ControlHint: "sn:ApprovingModeChoice"
  }, {
    Type: "NullFieldSetting",
    Name: "Locked",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Locked",
    Description: "It shows whether the content is checked out or not.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    Name: "CheckedOutTo",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Checked Out To",
    Description: "The user currently locking the content.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "TrashDisabled",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Disable Trash",
    Description: "You can disable trash for this content and its children. If set, you can not restore deleted content.",
    ReadOnly: false,
    Compulsory: false,
    DefaultValue: "false",
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "0",
      Text: "Finalized",
      Enabled: true,
      Selected: false
    }, {
      Value: "1",
      Text: "Creating",
      Enabled: true,
      Selected: false
    }, {
      Value: "2",
      Text: "Modifying",
      Enabled: true,
      Selected: false
    }, {
      Value: "3",
      Text: "ModifyingLocked",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "SenseNet.ContentRepository.Storage.ContentSavingState",
    Name: "SavingState",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Saving state",
    Description: "State of multi-step saving.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "LongTextFieldSetting",
    Name: "ExtensionData",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Extension data",
    Description: "You can set extra data in this field which is useful when extending a content.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    Name: "BrowseApplication",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Reference To Browse Application",
    Description: "Set this, if you would like to override the default browse application.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "Approvable",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Approvable By Current User",
    Description: "This fileld is true if the content is in 'pending' state and can be approved by the current user.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "IsTaggable",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Enable Tagging",
    Description: "Specify whether you would like to enable tagging capability for this content.",
    ReadOnly: false,
    Compulsory: false,
    DefaultValue: "false",
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "LongTextFieldSetting",
    Name: "Tags",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Tags",
    Description: "List of tags and creators of them separated by commas.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide,
    ControlHint: "sn:TagList"
  }, {
    Type: "NullFieldSetting",
    Name: "IsRateable",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Enable Rating",
    Description: "Specify whether you would like to enable rating capability for this content.",
    ReadOnly: false,
    Compulsory: false,
    DefaultValue: "false",
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "RateStr",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Raw value of rating",
    Description: "",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NumberFieldSetting",
    Name: "RateAvg",
    FieldClassName: "SenseNet.ContentRepository.Fields.NumberField",
    DisplayName: "Average rate",
    Description: "Average rate of the content.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "RateCount",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Rate count",
    Description: "Count of rates.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "RatingFieldSetting",
    Range: 5,
    Split: 1,
    Name: "Rate",
    FieldClassName: "SenseNet.ContentRepository.Fields.RatingField",
    DisplayName: "Rate",
    Description: "",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "Publishable",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Publishable By Current User",
    Description: "This fileld is true if the content can be published by the current user.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: true,
    Name: "Versions",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Versions",
    Description: "Content version history.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "LongTextFieldSetting",
    Name: "CheckInComments",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Checkin comments",
    Description: "Comments for a new version.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "LongTextFieldSetting",
    Name: "RejectReason",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Reject reason",
    Description: "The reason why the content was rejected.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    AllowedTypes: ["Workspace"],
    Name: "Workspace",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Workspace",
    Description: "The container workspace of the content.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "BrowseUrl",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Browse url",
    Description: "",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Name: "VersionModifiedBy",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Version is Modified By",
    Description: "Version was last modified by this user.",
    ReadOnly: false,
    Compulsory: false,
    OutputMethod: 0,
    VisibleBrowse: 1,
    VisibleEdit: 1,
    VisibleNew: 1,
    Type: "ReferenceFieldSetting"
  }, {
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "VersionModificationDate",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Versions Modification Date",
    Description: "Version was last modified on this date.",
    ReadOnly: false,
    Compulsory: false,
    OutputMethod: 0,
    VisibleBrowse: 1,
    VisibleEdit: 1,
    VisibleNew: 1,
    Type: "DateTimeFieldSetting"
  }, {
    Name: "VersionCreatedBy",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Version is created By",
    Description: "Version was last created by this user.",
    ReadOnly: false,
    Compulsory: false,
    OutputMethod: 0,
    VisibleBrowse: 1,
    VisibleEdit: 1,
    VisibleNew: 1,
    Type: "ReferenceFieldSetting"
  }, {
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "VersionCreationDate",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Versions Creation Date",
    Description: "Version was created on this date.",
    ReadOnly: false,
    Compulsory: false,
    OutputMethod: 0,
    VisibleBrowse: 1,
    VisibleEdit: 1,
    VisibleNew: 1,
    Type: "DateTimeFieldSetting"
  }],
  HandlerName: "SenseNet.ContentRepository.GenericContent"
}, {
  ContentTypeName: "ContentLink",
  ParentTypeName: "GenericContent",
  DisplayName: "$Ctd-ContentLink,DisplayName",
  Description: "$Ctd-ContentLink,Description",
  Icon: "Folder",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    Name: "Link",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Linked content",
    Description: "Set this reference to the Content to link.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ContentRepository.ContentLink"
}, {
  ContentTypeName: "File",
  ParentTypeName: "GenericContent",
  DisplayName: "$Ctd-File,DisplayName",
  Description: "$Ctd-File,Description",
  Icon: "File",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "BinaryFieldSetting",
    Name: "Binary",
    FieldClassName: "SenseNet.ContentRepository.Fields.BinaryField",
    DisplayName: "Binary",
    Description: "The binary content of the document.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NumberFieldSetting",
    Name: "Size",
    FieldClassName: "SenseNet.ContentRepository.Fields.NumberField",
    DisplayName: "Size",
    Description: "Size of the binary document.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NumberFieldSetting",
    Name: "FullSize",
    FieldClassName: "SenseNet.ContentRepository.Fields.NumberField",
    DisplayName: "Full size",
    Description: "The total amount of space the Document occupies, counting all versions.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "PageCount",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Page count",
    Description: "Read-only field for storing the number of pages in the document. It is filled by the document preview generator.",
    ReadOnly: false,
    Compulsory: false,
    DefaultValue: "-4",
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "MimeType",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Document MIME type",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "LongTextFieldSetting",
    Name: "Shapes",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Shapes",
    Description: "Stores data used for document preview (redaction, highlight, annotation shapes). This value can be modified by the document preview plugin.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "LongTextFieldSetting",
    Name: "PageAttributes",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Page attributes",
    Description: "Stores data used for document preview (for example page rotation). This value can be modified by the document preview plugin.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "Watermark",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Watermark",
    Description: "The text that is displayed as a watermark on the document preview. The format can be set by modifying the Document Preview settings.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ContentRepository.File"
}, {
  ContentTypeName: "DynamicJsonContent",
  ParentTypeName: "File",
  DisplayName: "Dynamic JSON content",
  Description: "",
  Icon: "Settings",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.Portal.Handlers.DynamicJsonContent"
}, {
  ContentTypeName: "ExecutableFile",
  ParentTypeName: "File",
  DisplayName: "$Ctd-ExecutableFile,DisplayName",
  Description: "$Ctd-ExecutableFile,Description",
  Icon: "Application",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.File"
}, {
  ContentTypeName: "HtmlTemplate",
  ParentTypeName: "File",
  DisplayName: "$Ctd-HtmlTemplate,DisplayName",
  Description: "$Ctd-HtmlTemplate,Description",
  Icon: "File",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "LongTextFieldSetting",
    Name: "TemplateText",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Template text",
    Description: "Shows the contents of the html file as a text.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.Portal.UI.HtmlTemplate"
}, {
  ContentTypeName: "Image",
  ParentTypeName: "File",
  DisplayName: "$Ctd-Image,DisplayName",
  Description: "$Ctd-Image,Description",
  Icon: "Image",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "LongTextFieldSetting",
    Name: "Keywords",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Keywords",
    Description: "Keywords describing the image.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "DateTaken",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Date taken",
    Description: "Date the photo was taken, if applicable.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "IntegerFieldSetting",
    Name: "Width",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Width",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "IntegerFieldSetting",
    Name: "Height",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Height",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ContentRepository.Image"
}, {
  ContentTypeName: "PreviewImage",
  ParentTypeName: "Image",
  DisplayName: "$Ctd-PreviewImage,DisplayName",
  Description: "$Ctd-PreviewImage,Description",
  Icon: "Image",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.Image"
}, {
  ContentTypeName: "Settings",
  ParentTypeName: "File",
  DisplayName: "$Ctd-Settings,DisplayName",
  Description: "$Ctd-Settings,Description",
  Icon: "Settings",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "NullFieldSetting",
    Name: "GlobalOnly",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Global only",
    Description: "Switching this ON will prevent the creation of local settings with the same name preventing others to gain access to the contents of this settings file through inheritance.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ContentRepository.Settings"
}, {
  ContentTypeName: "IndexingSettings",
  ParentTypeName: "Settings",
  DisplayName: "$Ctd-IndexingSettings,DisplayName",
  Description: "$Ctd-IndexingSettings,Description",
  Icon: "Settings",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "NullFieldSetting",
    Name: "TextExtractorInstances",
    FieldClassName: "SenseNet.Search.TextExtractorsField",
    DisplayName: "Text extractor instances",
    Description: "Dynamically generated text extractor instance collection.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.Search.IndexingSettings"
}, {
  ContentTypeName: "LoggingSettings",
  ParentTypeName: "Settings",
  DisplayName: "$Ctd-LoggingSettings,DisplayName",
  Description: "$Ctd-LoggingSettings,Description",
  Icon: "Settings",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.LoggingSettings"
}, {
  ContentTypeName: "PortalSettings",
  ParentTypeName: "Settings",
  DisplayName: "$Ctd-PortalSettings,DisplayName",
  Description: "$Ctd-PortalSettings,Description",
  Icon: "Settings",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.Portal.PortalSettings"
}, {
  ContentTypeName: "SystemFile",
  ParentTypeName: "File",
  DisplayName: "$Ctd-SystemFile,DisplayName",
  Description: "$Ctd-SystemFile,Description",
  Icon: "File",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.File"
}, {
  ContentTypeName: "Resource",
  ParentTypeName: "SystemFile",
  DisplayName: "$Ctd-Resource,DisplayName",
  Description: "$Ctd-Resource,Description",
  Icon: "Resource",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "NumberFieldSetting",
    Name: "Downloads",
    FieldClassName: "SenseNet.ContentRepository.Fields.NumberField",
    DisplayName: "Downloads",
    Description: "The number of downloads.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.i18n.Resource"
}, {
  ContentTypeName: "Folder",
  ParentTypeName: "GenericContent",
  DisplayName: "$Ctd-Folder,DisplayName",
  Description: "$Ctd-Folder,Description",
  Icon: "Folder",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.Folder"
}, {
  ContentTypeName: "ContentList",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-ContentList,DisplayName",
  Description: "$Ctd-ContentList,Description",
  Icon: "ContentList",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "LongTextFieldSetting",
    Name: "ContentListDefinition",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "List Definition",
    Description: "XML definition for additional fields.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "DefaultView",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Default view",
    Description: "The default View to use.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: true,
    AllowedTypes: [],
    Name: "AvailableViews",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Available views",
    Description: "Select global content list views here that you want to offer users to choose from.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: true,
    AllowedTypes: [],
    Name: "FieldSettingContents",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "FieldSetting content",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: true,
    AllowedTypes: [],
    Name: "AvailableContentTypeFields",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Available ContentType Field content.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "ListEmail",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Email address of Content List",
    Description: "Emails sent to this address will be imported as Email content into the Document Library.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "ExchangeSubscriptionId",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Exchange Subscription Id",
    Description: "Ctd-ContentListen-USExchangeSubscriptionId-Descriptione",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "OverwriteFiles",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Overwrite files with same name",
    Description: "If checked new emails and attachments with the same name will overwrite existing items in list. Otherwise increment suffix is used in the name of new mail items.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "email",
      Text: "Save all attachments as children of separate Email content",
      Enabled: true,
      Selected: true
    }, {
      Value: "root",
      Text: "Save all attachments in root",
      Enabled: true,
      Selected: false
    }, {
      Value: "subject",
      Text: "Save all attachments in folders grouped by subject",
      Enabled: true,
      Selected: false
    }, {
      Value: "sender",
      Text: "Save all attachments in folders grouped by sender",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "GroupAttachments",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Group attachments",
    Description: "Select the appropriate option to group attachment files under folders or email content or not.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "SaveOriginalEmail",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Save original email",
    Description: "A separate .eml file will be created for every incoming email.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    SelectionRoots: ["/Root/System/Schema/ContentTypes/GenericContent/Workflow/MailProcessorWorkflow"],
    Name: "IncomingEmailWorkflow",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Incoming email workflow",
    Description: "Select the workflow to be executed on every incoming email.",
    ReadOnly: false,
    Compulsory: false,
    DefaultValue: "/Root/System/Schema/ContentTypes/GenericContent/Workflow/MailProcessorWorkflow",
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "OnlyFromLocalGroups",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Accept e-mails only from users in local groups",
    Description: "If set, only users that are members of any local group are able to send e-mails to this library.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "InboxFolder",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Inbox folder",
    Description: "A relative path of a folder to store incoming e-mails.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    AllowedTypes: ["User"],
    SelectionRoots: ["/Root/IMS"],
    Name: "OwnerWhenVisitor",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Owner of items created by visitor",
    Description: "If a Visitor adds content to this list, this user will be set as the creator instead of the Visitor. This prevents visitors see each others' content.",
    ReadOnly: false,
    Compulsory: false,
    DefaultValue: "/Root/IMS/BuiltIn/Portal/Admin",
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.ContentList"
}, {
  ContentTypeName: "Aspect",
  ParentTypeName: "ContentList",
  DisplayName: "$Ctd-Aspect,DisplayName",
  Description: "$Ctd-Aspect,Description",
  Icon: "Aspect",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "LongTextFieldSetting",
    Name: "AspectDefinition",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Aspect definition",
    Description: "Definition of the extension in XML format.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ContentRepository.Aspect"
}, {
  ContentTypeName: "ItemList",
  ParentTypeName: "ContentList",
  DisplayName: "$Ctd-ItemList,DisplayName",
  Description: "$Ctd-ItemList,Description",
  Icon: "ContentList",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.ContentList"
}, {
  ContentTypeName: "CustomList",
  ParentTypeName: "ItemList",
  DisplayName: "$Ctd-CustomList,DisplayName",
  Description: "$Ctd-CustomList,Description",
  Icon: "ContentList",
  AllowedChildTypes: ["ListItem"],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.ContentList"
}, {
  ContentTypeName: "MemoList",
  ParentTypeName: "ItemList",
  DisplayName: "$Ctd-MemoList,DisplayName",
  Description: "$Ctd-MemoList,Description",
  Icon: "ContentList",
  AllowedChildTypes: ["Memo"],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.ContentList"
}, {
  ContentTypeName: "TaskList",
  ParentTypeName: "ItemList",
  DisplayName: "$Ctd-TaskList,DisplayName",
  Description: "$Ctd-TaskList,Description",
  Icon: "ContentList",
  AllowedChildTypes: ["Task"],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.ContentList"
}, {
  ContentTypeName: "Library",
  ParentTypeName: "ContentList",
  DisplayName: "$Ctd-Library,DisplayName",
  Description: "$Ctd-Library,Description",
  Icon: "ContentList",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.ContentList"
}, {
  ContentTypeName: "DocumentLibrary",
  ParentTypeName: "Library",
  DisplayName: "$Ctd-DocumentLibrary,DisplayName",
  Description: "$Ctd-DocumentLibrary,Description",
  Icon: "ContentList",
  AllowedChildTypes: ["Folder", "File"],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.ContentList"
}, {
  ContentTypeName: "ImageLibrary",
  ParentTypeName: "Library",
  DisplayName: "$Ctd-ImageLibrary,DisplayName",
  Description: "$Ctd-ImageLibrary,Description",
  Icon: "ContentList",
  AllowedChildTypes: ["Folder", "Image"],
  FieldSettings: [{
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    AllowedTypes: ["Image"],
    Name: "CoverImage",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Cover image",
    Description: "Select cover image",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.ContentList"
}, {
  ContentTypeName: "Device",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-Device,DisplayName",
  Description: "$Ctd-Device,Description",
  Icon: "Device",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "ShortTextFieldSetting",
    Name: "UserAgentPattern",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "User agent string",
    Description: "A regular expression to match the user agent string of the browser.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ApplicationModel.Device"
}, {
  ContentTypeName: "Domain",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-Domain,DisplayName",
  Description: "$Ctd-Domain,Description",
  Icon: "Domain",
  AllowedChildTypes: ["User", "Group", "OrganizationalUnit"],
  FieldSettings: [{
    Type: "ShortTextFieldSetting",
    Name: "SyncGuid",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "SyncGuid",
    Description: "GUID of corresponding AD object.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "LastSync",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "LastSync",
    Description: "Date of last synchronization.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.Domain"
}, {
  ContentTypeName: "Domains",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-Domains,DisplayName",
  Description: "$Ctd-Domains,Description",
  Icon: "Folder",
  AllowedChildTypes: ["Domain"],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.Folder"
}, {
  ContentTypeName: "Email",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-Email,DisplayName",
  Description: "$Ctd-Email,Description",
  Icon: "Document",
  AllowedChildTypes: ["File"],
  FieldSettings: [{
    Type: "ShortTextFieldSetting",
    Name: "From",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "From",
    Description: "Sender name and address.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "LongTextFieldSetting",
    TextType: "RichText",
    Name: "Body",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Body",
    Description: "Body of email.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show,
    ControlHint: "sn:RichText"
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "Sent",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Sent",
    Description: "Date of sending.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ContentRepository.Folder"
}, {
  ContentTypeName: "OrganizationalUnit",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-OrganizationalUnit,DisplayName",
  Description: "$Ctd-OrganizationalUnit,Description",
  Icon: "OrgUnit",
  AllowedChildTypes: ["User", "Group", "OrganizationalUnit"],
  FieldSettings: [{
    Type: "ShortTextFieldSetting",
    Name: "SyncGuid",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "SyncGuid",
    Description: "GUID of corresponding AD object.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "LastSync",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "LastSync",
    Description: "Date of last synchronization.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.OrganizationalUnit"
}, {
  ContentTypeName: "PortalRoot",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-PortalRoot,DisplayName",
  Description: "$Ctd-PortalRoot,Description",
  Icon: "PortalRoot",
  AllowedChildTypes: ["Folder", "SystemFolder", "TrashBin", "ContentList", "CustomList", "Sites", "Domains", "Profiles", "Resources", "Workspace"],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.PortalRoot"
}, {
  ContentTypeName: "ProfileDomain",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-ProfileDomain,DisplayName",
  Description: "$Ctd-ProfileDomain,Description",
  Icon: "Domain",
  AllowedChildTypes: ["UserProfile"],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.Folder"
}, {
  ContentTypeName: "Profiles",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-Profiles,DisplayName",
  Description: "$Ctd-Profiles,Description",
  Icon: "Folder",
  AllowedChildTypes: ["ProfileDomain"],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.Folder"
}, {
  ContentTypeName: "RuntimeContentContainer",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-RuntimeContentContainer,DisplayName",
  Description: "$Ctd-RuntimeContentContainer,Description",
  Icon: "Folder",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.RuntimeContentContainer"
}, {
  ContentTypeName: "Sites",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-Sites,DisplayName",
  Description: "$Ctd-Sites,Description",
  Icon: "Site",
  AllowedChildTypes: ["Site"],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.Folder"
}, {
  ContentTypeName: "SmartFolder",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-SmartFolder,DisplayName",
  Description: "$Ctd-SmartFolder,Description",
  Icon: "SmartFolder",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "LongTextFieldSetting",
    Name: "Query",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Query",
    Description: "Please give a query here that you want to use for collecting the children of this smart folder.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show,
    ControlHint: "sn:QueryBuilder"
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "0",
      Text: "Default",
      Enabled: true,
      Selected: false
    }, {
      Value: "1",
      Text: "Enabled",
      Enabled: true,
      Selected: false
    }, {
      Value: "2",
      Text: "Disabled",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "SenseNet.Search.FilterStatus",
    Name: "EnableAutofilters",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Enable autofilters",
    Description: "If autofilters are enabled, system content will be filtered from the query.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "0",
      Text: "Default",
      Enabled: true,
      Selected: false
    }, {
      Value: "1",
      Text: "Enabled",
      Enabled: true,
      Selected: false
    }, {
      Value: "2",
      Text: "Disabled",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "SenseNet.Search.FilterStatus",
    Name: "EnableLifespanFilter",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Enable lifespan filter",
    Description: "If lifespan filter is enabled, only valid content will be in the result.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ContentRepository.SmartFolder"
}, {
  ContentTypeName: "SystemFolder",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-SystemFolder,DisplayName",
  Description: "$Ctd-SystemFolder,Description",
  Icon: "Folder",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.SystemFolder"
}, {
  ContentTypeName: "Resources",
  ParentTypeName: "SystemFolder",
  DisplayName: "$Ctd-Resources,DisplayName",
  Description: "$Ctd-Resources,Description",
  Icon: "Folder",
  AllowedChildTypes: ["Resource"],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.SystemFolder"
}, {
  ContentTypeName: "TrashBag",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-TrashBag,DisplayName",
  Description: "$Ctd-TrashBag,Description",
  Icon: "Folder",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "DateTimeFieldSetting",
    Name: "KeepUntil",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Keep until",
    Description: "The bag must be kept until this date.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Name: "OriginalPath",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Original path",
    Description: "The path where the bag content were deleted from.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Name: "WorkspaceRelativePath",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Ctd-TrashBagen-USWorkspaceRelativePath-DisplayName",
    Description: "Ctd-TrashBagen-USWorkspaceRelativePath-Description",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "IntegerFieldSetting",
    Name: "WorkspaceId",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Ctd-TrashBagen-USWorkspaceId-DisplayName",
    Description: "Ctd-TrashBagen-USWorkspaceId-Description",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    Name: "DeletedContent",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Deleted content",
    Description: "The actual deleted content inside this trash bag.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.TrashBag"
}, {
  ContentTypeName: "Workspace",
  ParentTypeName: "Folder",
  DisplayName: "$Ctd-Workspace,DisplayName",
  Description: "$Ctd-Workspace,Description",
  Icon: "Workspace",
  AllowedChildTypes: ["Folder", "DocumentLibrary", "ImageLibrary", "MemoList", "TaskList", "CustomList", "Workspace"],
  FieldSettings: [{
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    AllowedTypes: ["User"],
    SelectionRoots: ["/Root/IMS", "/Root"],
    Name: "Manager",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Project manager",
    Description: "The person responsible for the project.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "Deadline",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Project deadline",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "IsActive",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Active",
    Description: "This workspace is currently active.",
    ReadOnly: false,
    Compulsory: true,
    DefaultValue: "true",
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    AllowedTypes: [],
    SelectionRoots: ["/Root/Skins"],
    Name: "WorkspaceSkin",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Skin",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "IsCritical",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Is critical",
    Description: "This workspace is currently in a critical status.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "IsWallContainer",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Wall Container",
    Description: "This workspace is configured to contain a wall - this indicates that posts are created under this workspace if Content are shared anywhere below this path.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "IsFollowed",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.Workspaces.Workspace"
}, {
  ContentTypeName: "Site",
  ParentTypeName: "Workspace",
  DisplayName: "$Ctd-Site,DisplayName",
  Description: "$Ctd-Site,Description",
  Icon: "Site",
  AllowedChildTypes: ["Folder", "Workspace", "Profiles", "Image", "DocumentLibrary", "ImageLibrary", "MemoList", "TaskList", "CustomList", "SmartFolder"],
  FieldSettings: [{
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "en",
      Text: "English",
      Enabled: true,
      Selected: true
    }, {
      Value: "hu",
      Text: "Hungarian",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "Language",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Language",
    Description: "Please define the default language of this site.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "NullFieldSetting",
    Name: "EnableClientBasedCulture",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Enable client-based culture",
    Description: "Enable this to allow user browser settings override default site language settings.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "NullFieldSetting",
    Name: "EnableUserBasedCulture",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Enable user-based culture",
    Description: "Enable this to allow user language settings override default site language settings.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "NullFieldSetting",
    Name: "UrlList",
    FieldClassName: "SenseNet.ContentRepository.Fields.UrlListField",
    DisplayName: "URL list",
    Description: "Select the URLs to associate with this Site.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    SelectionRoots: ["."],
    Name: "StartPage",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Alternative start page",
    Description: "If set, the site will use this start page instead of the default.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    SelectionRoots: ["."],
    Name: "LoginPage",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Login page",
    Description: "The login page to display when a user tries to access restricted Content (Forms authentication only).",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    AllowedTypes: [],
    SelectionRoots: ["/Root/Skins"],
    Name: "SiteSkin",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Skin",
    Description: "",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "NullFieldSetting",
    Name: "DenyCrossSiteAccess",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Deny cross-site access",
    Description: "If set, content under this site can only be accessed via this site and not via other sites using a Root relative path.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.Portal.Site"
}, {
  ContentTypeName: "TrashBin",
  ParentTypeName: "Workspace",
  DisplayName: "$Ctd-TrashBin,DisplayName",
  Description: "$Ctd-TrashBin,Description",
  Icon: "trash",
  AllowedChildTypes: ["TrashBag"],
  FieldSettings: [{
    Type: "IntegerFieldSetting",
    MinValue: 0,
    Name: "MinRetentionTime",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Minimum retention time (in days)",
    Description: "",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "IntegerFieldSetting",
    MinValue: 0,
    Name: "SizeQuota",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Size quota",
    Description: "Set the size quote for the trash bin (Megabytes).",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "IntegerFieldSetting",
    MinValue: 0,
    Name: "BagCapacity",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Trashbag capacity",
    Description: "The maximum number of nodes accepted for trash in a single operation.",
    ReadOnly: false,
    Compulsory: false,
    DefaultValue: "100",
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ContentRepository.TrashBin"
}, {
  ContentTypeName: "UserProfile",
  ParentTypeName: "Workspace",
  DisplayName: "$Ctd-UserProfile,DisplayName",
  Description: "$Ctd-UserProfile,Description",
  Icon: "UserProfile",
  AllowedChildTypes: ["DocumentLibrary", "MemoList", "TaskList", "ImageLibrary", "CustomList"],
  FieldSettings: [{
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    AllowedTypes: ["User"],
    SelectionRoots: ["/Root/IMS"],
    Name: "User",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "User",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ContentRepository.UserProfile"
}, {
  ContentTypeName: "Group",
  ParentTypeName: "GenericContent",
  DisplayName: "$Ctd-Group,DisplayName",
  Description: "$Ctd-Group,Description",
  Icon: "Group",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "ReferenceFieldSetting",
    AllowMultiple: true,
    AllowedTypes: ["User", "Group"],
    SelectionRoots: ["/Root/IMS", "/Root"],
    Name: "Members",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Members",
    Description: "The members of this group.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show,
    FieldIndex: 20
  }, {
    Type: "ShortTextFieldSetting",
    Name: "SyncGuid",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Sync Guid",
    Description: "GUID of corresponding AD object.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "LastSync",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Last synchronization",
    Description: "Date of last synchronization.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.Group"
}, {
  ContentTypeName: "ListItem",
  ParentTypeName: "GenericContent",
  DisplayName: "$Ctd-ListItem,DisplayName",
  Description: "$Ctd-ListItem,Description",
  Icon: "FormItem",
  AllowedChildTypes: [],
  FieldSettings: [],
  HandlerName: "SenseNet.ContentRepository.GenericContent"
}, {
  ContentTypeName: "CustomListItem",
  ParentTypeName: "ListItem",
  DisplayName: "$Ctd-CustomListItem,DisplayName",
  Description: "$Ctd-CustomListItem,Description",
  Icon: "FormItem",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "NullFieldSetting",
    Name: "WorkflowsRunning",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.GenericContent"
}, {
  ContentTypeName: "Memo",
  ParentTypeName: "ListItem",
  DisplayName: "$Ctd-Memo,DisplayName",
  Description: "$Ctd-Memo,Description",
  Icon: "Document",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "Date",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Date",
    Description: "Please set the due date of the memo.",
    ReadOnly: false,
    Compulsory: false,
    DefaultValue: "[Script:jScript] DateTime.UtcNow; [/Script]",
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: true,
    AllowMultiple: false,
    Options: [{
      Value: "generic",
      Text: "Generic",
      Enabled: true,
      Selected: true
    }, {
      Value: "iso",
      Text: "ISO",
      Enabled: true,
      Selected: false
    }, {
      Value: "iaudit",
      Text: "Internal audit",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "MemoType",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Memo type",
    Description: "Type of the memo.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: true,
    Name: "SeeAlso",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "See also...",
    Description: "A list of content this memo pertains to.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ContentRepository.GenericContent"
}, {
  ContentTypeName: "Task",
  ParentTypeName: "ListItem",
  DisplayName: "$Ctd-Task,DisplayName",
  Description: "$Ctd-Task,Description",
  Icon: "FormItem",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "StartDate",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Start date",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "DueDate",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Due date",
    ReadOnly: false,
    Compulsory: true,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: true,
    AllowedTypes: ["User"],
    SelectionRoots: ["/Root/IMS", "/Root"],
    Name: "AssignedTo",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Assigned to",
    Description: "List of internal stakeholders.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "1",
      Text: "Urgent",
      Enabled: true,
      Selected: false
    }, {
      Value: "2",
      Text: "Normal",
      Enabled: true,
      Selected: true
    }, {
      Value: "3",
      Text: "Not urgent",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "Priority",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Priority",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "pending",
      Text: "Pending",
      Enabled: true,
      Selected: false
    }, {
      Value: "active",
      Text: "Active",
      Enabled: true,
      Selected: true
    }, {
      Value: "completed",
      Text: "Completed",
      Enabled: true,
      Selected: false
    }, {
      Value: "deferred",
      Text: "Deferred",
      Enabled: true,
      Selected: false
    }, {
      Value: "waiting",
      Text: "Waiting",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "Status",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Status",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "IntegerFieldSetting",
    MinValue: 0,
    MaxValue: 100,
    ShowAsPercentage: true,
    Name: "TaskCompletion",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Completion",
    Description: "Completion percentage of the task.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "IntegerFieldSetting",
    Name: "RemainingDays",
    FieldClassName: "SenseNet.ContentRepository.Fields.IntegerField",
    DisplayName: "Remaining days",
    Description: "Number of remaining days.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "DueText",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "DueText",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "DueCssClass",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Due style",
    Description: "Css class",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.Task"
}, {
  ContentTypeName: "Query",
  ParentTypeName: "GenericContent",
  DisplayName: "$Ctd-Query,DisplayName",
  Description: "$Ctd-Query,Description",
  Icon: "Query",
  AllowedChildTypes: [],
  FieldSettings: [{
    Type: "LongTextFieldSetting",
    Name: "Query",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Query",
    Description: "Query text.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show,
    ControlHint: "sn:QueryBuilder"
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "Public",
      Text: "Public",
      Enabled: true,
      Selected: true
    }, {
      Value: "Private",
      Text: "Private",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.RadioButtons,
    EnumTypeName: "",
    Name: "QueryType",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Query type",
    Description: "Public queries are stored under the workspace, private queries are stored under the user profile.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }],
  HandlerName: "SenseNet.ContentRepository.QueryContent"
}, {
  ContentTypeName: "User",
  ParentTypeName: "GenericContent",
  DisplayName: "$Ctd-User,DisplayName",
  Description: "$Ctd-User,Description",
  Icon: "User",
  AllowedChildTypes: ["Image"],
  FieldSettings: [{
    Type: "ShortTextFieldSetting",
    MaxLength: 100,
    Name: "LoginName",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Login name",
    Description: "The name that the user has to type in on login forms (in some cases along with the domain name). It has to be unique under a domain.",
    ReadOnly: false,
    Compulsory: true,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Name: "JobTitle",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Job title",
    Description: "",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "NullFieldSetting",
    Name: "Enabled",
    FieldClassName: "SenseNet.ContentRepository.Fields.BooleanField",
    DisplayName: "Enabled",
    Description: "User account is enabled.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Name: "Domain",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Domain",
    Description: "The domain of the user.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Regex: "^[a-zA-Z0-9._%+-]+@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,}$",
    Name: "Email",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "E-mail",
    Description: "The e-mail of the user.",
    ReadOnly: false,
    Compulsory: true,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Regex: "[^<]+",
    Name: "FullName",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Full name",
    Description: "Full name of the user (e.g. John Smith).",
    ReadOnly: false,
    Compulsory: true,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    Name: "ImageRef",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Cover image (reference)",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "BinaryFieldSetting",
    Name: "ImageData",
    FieldClassName: "SenseNet.ContentRepository.Fields.BinaryField",
    DisplayName: "Cover image (binarydata)",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "NullFieldSetting",
    Name: "Avatar",
    FieldClassName: "SenseNet.ContentRepository.Fields.ImageField",
    DisplayName: "Avatar",
    Description: "Avatar image of user.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show,
    ControlHint: "sn:Image"
  }, {
    Type: "PasswordFieldSetting",
    ReenterTitle: "Re-enter password",
    ReenterDescription: "Re-enter password.",
    PasswordHistoryLength: 0,
    Name: "Password",
    FieldClassName: "SenseNet.ContentRepository.Fields.PasswordField",
    DisplayName: "Password",
    Description: "User password.",
    ReadOnly: false,
    Compulsory: true,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Name: "SyncGuid",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "SyncGuid",
    Description: "GUID of corresponding AD object.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "LastSync",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "LastSync",
    Description: "Date of last synchronization.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "CaptchaFieldSetting",
    Name: "Captcha",
    FieldClassName: "SenseNet.ContentRepository.Fields.CaptchaField",
    DisplayName: "Captcha text",
    Description: "Captcha text entered by the user.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: false,
    AllowedTypes: ["User"],
    SelectionRoots: ["/Root/IMS"],
    Name: "Manager",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Manager",
    Description: "Manager of the user.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Name: "Department",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Department",
    Description: "Department of employee.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Name: "Languages",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Languages",
    Description: "Spoken languages.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ShortTextFieldSetting",
    Regex: "(^\\d*([-\\s\\+\\(\\)]\\d*)*$)?",
    Name: "Phone",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Phone",
    Description: "Phone number. (e.g. +123456789 or 1234).",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "...",
      Text: "...",
      Enabled: true,
      Selected: false
    }, {
      Value: "Female",
      Text: "Female",
      Enabled: true,
      Selected: false
    }, {
      Value: "Male",
      Text: "Male",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "Gender",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Gender",
    Description: "Select one.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "...",
      Text: "...",
      Enabled: true,
      Selected: false
    }, {
      Value: "Single",
      Text: "Single",
      Enabled: true,
      Selected: false
    }, {
      Value: "Married",
      Text: "Married",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "MaritalStatus",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Marital status",
    Description: "Select one.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.Date,
    Name: "BirthDate",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Birth date",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "LongTextFieldSetting",
    TextType: "LongText",
    Name: "Education",
    FieldClassName: "SenseNet.ContentRepository.Fields.LongTextField",
    DisplayName: "Education",
    Description: "List of educations - e.g. high school, university.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide,
    ControlHint: "sn:EducationEditor"
  }, {
    Type: "ShortTextFieldSetting",
    Name: "TwitterAccount",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Twitter account",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "FacebookURL",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Facebook URL",
    Description: "http://www.facebook.com/USERNAME.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "LinkedInURL",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "LinkedIn URL",
    Description: "http://www.linkedin.com/USERNAME.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ChoiceFieldSetting",
    AllowExtraValue: false,
    AllowMultiple: false,
    Options: [{
      Value: "en",
      Text: "English",
      Enabled: true,
      Selected: true
    }, {
      Value: "hu",
      Text: "Hungarian",
      Enabled: true,
      Selected: false
    }],
    DisplayChoice: DisplayChoice.DropDown,
    EnumTypeName: "",
    Name: "Language",
    FieldClassName: "SenseNet.ContentRepository.Fields.ChoiceField",
    DisplayName: "Selected language",
    Description: "Language used to display texts on the site, if it is available.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Show,
    VisibleEdit: FieldVisibility.Show,
    VisibleNew: FieldVisibility.Show
  }, {
    Type: "ReferenceFieldSetting",
    AllowMultiple: true,
    AllowedTypes: ["Workspace"],
    Name: "FollowedWorkspaces",
    FieldClassName: "SenseNet.ContentRepository.Fields.ReferenceField",
    DisplayName: "Followed workspaces",
    Description: "List of workspaces followed by the user.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "ShortTextFieldSetting",
    Name: "ProfilePath",
    FieldClassName: "SenseNet.ContentRepository.Fields.ShortTextField",
    DisplayName: "Profile path",
    Description: "Path of the user's personal workspace.",
    ReadOnly: true,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }, {
    Type: "DateTimeFieldSetting",
    DateTimeMode: DateTimeMode.DateAndTime,
    Name: "LastLoggedOut",
    FieldClassName: "SenseNet.ContentRepository.Fields.DateTimeField",
    DisplayName: "Last logout date",
    Description: "Date and time of when the user logged out from all devices.",
    ReadOnly: false,
    Compulsory: false,
    VisibleBrowse: FieldVisibility.Hide,
    VisibleEdit: FieldVisibility.Hide,
    VisibleNew: FieldVisibility.Hide
  }],
  HandlerName: "SenseNet.ContentRepository.Users"
}];

// ../../node_modules/@sensenet/default-content-types/dist/esm/Enums.js
var VersioningMode;
(function(VersioningMode2) {
  VersioningMode2["Option0"] = "0";
  VersioningMode2["Option1"] = "1";
  VersioningMode2["Option2"] = "2";
  VersioningMode2["Option3"] = "3";
})(VersioningMode || (VersioningMode = {}));
var InheritableVersioningMode;
(function(InheritableVersioningMode2) {
  InheritableVersioningMode2["Option0"] = "0";
  InheritableVersioningMode2["Option1"] = "1";
  InheritableVersioningMode2["Option2"] = "2";
  InheritableVersioningMode2["Option3"] = "3";
})(InheritableVersioningMode || (InheritableVersioningMode = {}));
var ApprovingMode;
(function(ApprovingMode2) {
  ApprovingMode2["Option0"] = "0";
  ApprovingMode2["Option1"] = "1";
  ApprovingMode2["Option2"] = "2";
})(ApprovingMode || (ApprovingMode = {}));
var InheritableApprovingMode;
(function(InheritableApprovingMode2) {
  InheritableApprovingMode2["Option0"] = "0";
  InheritableApprovingMode2["Option1"] = "1";
  InheritableApprovingMode2["Option2"] = "2";
})(InheritableApprovingMode || (InheritableApprovingMode = {}));
var SavingState;
(function(SavingState2) {
  SavingState2["Finalized"] = "0";
  SavingState2["Creating"] = "1";
  SavingState2["Modifying"] = "2";
  SavingState2["ModifyingLocked"] = "3";
})(SavingState || (SavingState = {}));
var GroupAttachments;
(function(GroupAttachments2) {
  GroupAttachments2["email"] = "email";
  GroupAttachments2["root"] = "root";
  GroupAttachments2["subject"] = "subject";
  GroupAttachments2["sender"] = "sender";
})(GroupAttachments || (GroupAttachments = {}));
var EnableAutofilters;
(function(EnableAutofilters2) {
  EnableAutofilters2["Default"] = "0";
  EnableAutofilters2["Enabled"] = "1";
  EnableAutofilters2["Disabled"] = "2";
})(EnableAutofilters || (EnableAutofilters = {}));
var EnableLifespanFilter;
(function(EnableLifespanFilter2) {
  EnableLifespanFilter2["Default"] = "0";
  EnableLifespanFilter2["Enabled"] = "1";
  EnableLifespanFilter2["Disabled"] = "2";
})(EnableLifespanFilter || (EnableLifespanFilter = {}));
var Language;
(function(Language2) {
  Language2["En"] = "en";
  Language2["Hu"] = "hu";
})(Language || (Language = {}));
var MemoType;
(function(MemoType2) {
  MemoType2["generic"] = "generic";
  MemoType2["iso"] = "iso";
  MemoType2["iaudit"] = "iaudit";
})(MemoType || (MemoType = {}));
var Priority;
(function(Priority2) {
  Priority2["Option0"] = "1";
  Priority2["Option1"] = "2";
  Priority2["Option2"] = "3";
})(Priority || (Priority = {}));
var Status;
(function(Status2) {
  Status2["pending"] = "pending";
  Status2["active"] = "active";
  Status2["completed"] = "completed";
  Status2["deferred"] = "deferred";
  Status2["waiting"] = "waiting";
})(Status || (Status = {}));
var QueryType;
(function(QueryType2) {
  QueryType2["Public"] = "Public";
  QueryType2["Private"] = "Private";
})(QueryType || (QueryType = {}));
var Gender;
(function(Gender2) {
  Gender2["Option0"] = "...";
  Gender2["Female"] = "Female";
  Gender2["Male"] = "Male";
})(Gender || (Gender = {}));
var MaritalStatus;
(function(MaritalStatus2) {
  MaritalStatus2["Option0"] = "...";
  MaritalStatus2["Single"] = "Single";
  MaritalStatus2["Married"] = "Married";
})(MaritalStatus || (MaritalStatus = {}));
var EventType;
(function(EventType2) {
  EventType2["Deadline"] = "Deadline";
  EventType2["Meeting"] = "Meeting";
  EventType2["Demo"] = "Demo";
})(EventType || (EventType = {}));

// ../../node_modules/@sensenet/default-content-types/dist/esm/Security.js
var IdentityKind;
(function(IdentityKind2) {
  IdentityKind2["All"] = "All";
  IdentityKind2["Users"] = "Users";
  IdentityKind2["Groups"] = "Groups";
  IdentityKind2["OrganizationalUnits"] = "OrganizationalUnits";
  IdentityKind2["UsersAndGroups"] = "UsersAndGroups";
  IdentityKind2["UsersAndOrganizationalUnits"] = "UsersAndOrganizationalUnits";
  IdentityKind2["GroupsAndOrganizationalUnits"] = "GroupsAndOrganizationalUnits";
})(IdentityKind || (IdentityKind = {}));
var PermissionLevel;
(function(PermissionLevel2) {
  PermissionLevel2["AllowedOrDenied"] = "AllowedOrDenied";
  PermissionLevel2["Allowed"] = "Allowed";
  PermissionLevel2["Denied"] = "Denied";
})(PermissionLevel || (PermissionLevel = {}));
var PermissionValues = {
  undefined: 0,
  allow: 1,
  deny: 2
};
var permissionKeys = Object.keys(PermissionValues);
var Inheritance;
(function(Inheritance2) {
  Inheritance2["Break"] = "break";
  Inheritance2["Unbreak"] = "unbreak";
})(Inheritance || (Inheritance = {}));

// ../../node_modules/@sensenet/client-core/dist/esm/Repository/RepositoryConfiguration.js
var DEFAULT_SERVICE_TOKEN = "odata.svc";
var defaultRepositoryConfiguration = {
  chunkSize: 1e6,
  defaultEnableAutofilters: false,
  defaultEnableLifespanfilter: false,
  defaultInlineCount: "allpages",
  defaultMetadata: "no",
  defaultSelect: ["DisplayName", "Description", "Icon"],
  defaultTop: 1e4,
  oDataToken: DEFAULT_SERVICE_TOKEN,
  repositoryUrl: "",
  requiredSelect: ["Id", "Path", "Name", "Type"],
  schemas: SchemaStore2,
  identityServerUrl: ""
};

// ../../node_modules/@sensenet/client-core/dist/esm/Repository/Security.js
var Security = class {
  constructor(repository) {
    this.repository = repository;
    this.setPermissions = (idOrPath, permissionRequestBody) => this.repository.executeAction({
      name: "SetPermissions",
      idOrPath,
      method: "POST",
      body: {
        r: permissionRequestBody
      }
    });
    this.getAllPermissions = (contentIdOrPath) => this.repository.executeAction({
      idOrPath: contentIdOrPath,
      name: "GetPermissions",
      method: "GET",
      body: void 0
    });
    this.getAcl = (contentIdOrPath) => this.repository.executeAction({
      idOrPath: contentIdOrPath,
      name: "GetAcl",
      method: "GET"
    });
    this.getPermissionsForIdentity = (contentIdOrPath, identityPath) => this.repository.executeAction({
      idOrPath: contentIdOrPath,
      name: "GetPermissions",
      method: "GET",
      body: {
        identity: identityPath
      }
    });
    this.getRelatedIdentities = (options) => this.repository.executeAction({
      name: "GetRelatedIdentities",
      idOrPath: options.contentIdOrPath,
      method: "POST",
      body: {
        permissionLevel: options.level,
        indentityKind: options.kind
      },
      oDataOptions: options.oDataOptions
    });
    this.getRelatedPermissions = (options) => {
      var _options$includedType;
      return this.repository.executeAction({
        name: "GetRelatedPermissions",
        idOrPath: options.contentIdOrPath,
        method: "POST",
        body: {
          permissionLevel: options.level,
          explicitOnly: options.explicitOnly,
          memberPath: options.memberPath,
          includedTypes: (_options$includedType = options.includedTypes) !== null && _options$includedType !== void 0 ? _options$includedType : null
        },
        oDataOptions: options.oDataOptions
      });
    };
    this.getRelatedItems = (options) => this.repository.executeAction({
      name: "GetRelatedItems",
      idOrPath: options.contentIdOrPath,
      method: "POST",
      body: {
        permissionLevel: options.level,
        explicitOnly: options.explicitOnly,
        memberPath: options.member,
        permissions: options.permissions
      },
      oDataOptions: options.oDataOptions
    });
    this.getRelatedIdentitiesByPermissions = (options) => this.repository.executeAction({
      name: "GetRelatedIdentitiesByPermissions",
      idOrPath: options.contentIdOrPath,
      method: "POST",
      body: {
        permissionLevel: options.level,
        identityKind: options.kind,
        permissions: options.permissions
      },
      oDataOptions: options.oDataOptions
    });
    this.getRelatedItemsOneLevel = (options) => this.repository.executeAction({
      name: "GetRelatedItemsOneLevel",
      idOrPath: options.contentIdOrPath,
      method: "POST",
      body: {
        permissionLevel: options.level,
        memberPath: options.member,
        permissions: options.permissions
      },
      oDataOptions: options.oDataOptions
    });
    this.getAllowedUsers = (options) => this.repository.executeAction({
      idOrPath: options.contentIdOrPath,
      name: "GetAllowedUsers",
      method: "POST",
      body: {
        permissions: options.permissions
      },
      oDataOptions: options.oDataOptions
    });
    this.getParentGroups = (options) => this.repository.executeAction({
      name: "GetParentGroups",
      idOrPath: options.contentIdOrPath,
      method: "POST",
      body: {
        directOnly: options.directOnly
      },
      oDataOptions: options.oDataOptions,
      requestInit: options.requestInit
    });
    this.addMembers = (contentIdOrPath, contentIds) => this.repository.executeAction({
      name: "AddMembers",
      idOrPath: contentIdOrPath,
      method: "POST",
      body: {
        contentIds
      }
    });
    this.removeMembers = (contentIdOrPath, contentIds) => this.repository.executeAction({
      name: "RemoveMembers",
      idOrPath: contentIdOrPath,
      method: "POST",
      body: {
        contentIds
      }
    });
  }
  /**
   * Sets permissions on the requested content.
   * You can add or remove permissions for one ore more users or groups using this action.
   * @param {string | number} idOrPath A content id or path
   * @param {PermissionRequestBody} permissionRequestBody inheritance: break or unbreak
   * @returns {Promise<PermissionResponseModel>} A promise with a response model
   */
  /**
   * Gets if the given user has the specified permissions for the requested content.
   *
   * Required permissions to call this action: See permissions.
   * @param {string[]} permissions list of permission names (e.g. Open, Save)
   * @param {string} user path of the user (or the current user, if not provided)
   * @returns {Promise<boolean>} A promise with the response value
   */
  async hasPermission(contentIdOrPath, permissions, identityPath, requestInit) {
    let params = `permissions=${permissions.join(",")}`;
    if (identityPath) {
      params += `&identity=${identityPath}`;
    }
    const path = PathHelper.joinPaths(this.repository.configuration.repositoryUrl, this.repository.configuration.oDataToken, PathHelper.getContentUrl(contentIdOrPath));
    const response = await this.repository.fetch(`${path}/HasPermission?${params}`, requestInit);
    if (response.ok) {
      return await response.text() === "true" || false;
    } else {
      throw await this.repository.getErrorFromResponse(response);
    }
  }
  /**
   * Identity list that contains every users/groups/organizational units
   * that have any permission setting (according to permission level)
   * in the subtree of the context content.
   * @param {GetRelatedIdentities<TIdentityType>} options Options object for the method call
   * @returns {Promise<ODataCollectionResponse<TIdentityType>>} A promise that will be resolved with a collection of related identities
   */
};

// ../../node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// ../../node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// ../../node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// ../../node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// ../../node_modules/uuid/dist/esm-browser/v1.js
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var v1_default = v1;

// ../../node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// ../../node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

// ../../node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// ../../node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35_default("v3", 48, md5_default);

// ../../node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// ../../node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35_default("v5", 80, sha1_default);

// ../../node_modules/@sensenet/client-core/dist/esm/Repository/Upload.js
var Upload = class {
  constructor(repository) {
    this.repository = repository;
  }
  /**
   * Uploads a specified text as a binary file
   * @param {UploadTextOptions} options The additional options
   */
  async textAsFile(options) {
    const uploadFileOptions = Object.assign({
      file: new File([options.text], options.fileName)
    }, options);
    return await this.file(uploadFileOptions);
  }
  /**
   * Uploads a specified file into a sensenet Repository
   * @param {UploadFileOptions} options The additional upload options
   */
  async file(options) {
    if (this.isChunkedUploadNeeded(options.file)) {
      return await this.uploadChunked(options);
    }
    return await this.uploadNonChunked(options);
  }
  /**
   * Returns if a chunked upload is needed for a specified file
   * @param {File} file The File object
   */
  isChunkedUploadNeeded(file) {
    return file.size >= this.repository.configuration.chunkSize;
  }
  getUploadUrl(options) {
    return PathHelper.joinPaths(this.repository.configuration.repositoryUrl, this.repository.configuration.oDataToken, PathHelper.getContentUrl(options.parentPath), "upload");
  }
  getFormDataFromOptions(options) {
    const formData = new FormData();
    formData.append("ChunkToken", "0*0*False*False");
    formData.append("FileName", options.fileName || options.file.name);
    formData.append("Overwrite", options.overwrite.toString());
    formData.append("PropertyName", options.binaryPropertyName.toString());
    formData.append("FileLength", options.file.size.toString());
    if (options.contentTypeName) {
      formData.append("ContentType", options.contentTypeName.toString());
    }
    return formData;
  }
  async uploadNonChunked(options) {
    var _options$progressObse;
    const guid = v1_default();
    let responseContent = {};
    (_options$progressObse = options.progressObservable) === null || _options$progressObse === void 0 ? void 0 : _options$progressObse.setValue({
      guid,
      file: options.file,
      completed: false
    });
    const formData = this.getFormDataFromOptions(options);
    formData.append(options.file.name, options.file);
    try {
      const response = await this.repository.fetch(this.getUploadUrl(options), {
        ...options.requestInit,
        credentials: "include",
        method: "POST",
        body: formData
      });
      if (response.ok) {
        var _options$progressObse2;
        responseContent = await response.json();
        (_options$progressObse2 = options.progressObservable) === null || _options$progressObse2 === void 0 ? void 0 : _options$progressObse2.setValue({
          guid,
          file: options.file,
          chunkCount: 1,
          uploadedChunks: 1,
          completed: true,
          createdContent: responseContent
        });
      } else {
        throw await this.repository.getErrorFromResponse(response);
      }
      return responseContent;
    } catch (error) {
      var _options$progressObse3;
      (_options$progressObse3 = options.progressObservable) === null || _options$progressObse3 === void 0 ? void 0 : _options$progressObse3.setValue({
        guid,
        file: options.file,
        completed: false,
        error
      });
      throw error;
    }
  }
  async uploadChunked(options) {
    var _options$progressObse4;
    const chunkCount = Math.floor(options.file.size / this.repository.configuration.chunkSize);
    const guid = v1_default();
    (_options$progressObse4 = options.progressObservable) === null || _options$progressObse4 === void 0 ? void 0 : _options$progressObse4.setValue({
      guid,
      file: options.file,
      completed: false,
      chunkCount,
      uploadedChunks: 0
    });
    const uploadPath = this.getUploadUrl(options);
    const formData = this.getFormDataFromOptions(options);
    formData.append(options.file.name, options.file.slice(0, this.repository.configuration.chunkSize));
    formData.append("UseChunk", "true");
    formData.append("create", "1");
    try {
      const initRequest = await this.repository.fetch(uploadPath, {
        ...options.requestInit,
        body: formData,
        credentials: "include",
        method: "POST",
        headers: {
          "Content-Range": `bytes 0-${this.repository.configuration.chunkSize - 1}/${options.file.size}`,
          "Content-Disposition": `attachment; filename="${encodeURIComponent(options.file.name)}"`
        }
      });
      const chunkToken = await initRequest.text();
      let lastResponseContent = {};
      for (let i = 0; i <= chunkCount; i++) {
        const start = i * this.repository.configuration.chunkSize;
        let end = start + this.repository.configuration.chunkSize;
        end = end > options.file.size ? options.file.size : end;
        const chunkFormData = new FormData();
        const chunkData = options.file.slice(start, end);
        chunkFormData.append("FileLength", options.file.size.toString());
        chunkFormData.append("ChunkToken", chunkToken);
        chunkFormData.append("PropertyName", options.binaryPropertyName.toString());
        chunkFormData.append(options.file.name, chunkData);
        const lastResponse = await this.repository.fetch(uploadPath, {
          ...options.requestInit,
          body: chunkFormData,
          credentials: "include",
          method: "POST",
          headers: {
            "Content-Range": `bytes ${start}-${end - 1}/${options.file.size}`,
            "Content-Disposition": `attachment; filename="${encodeURIComponent(options.file.name)}"`
          }
        });
        if (lastResponse.ok) {
          var _options$progressObse5;
          lastResponseContent = await lastResponse.json();
          (_options$progressObse5 = options.progressObservable) === null || _options$progressObse5 === void 0 ? void 0 : _options$progressObse5.setValue({
            guid,
            file: options.file,
            chunkCount,
            uploadedChunks: i,
            completed: i === chunkCount,
            createdContent: lastResponseContent
          });
        } else {
          throw await this.repository.getErrorFromResponse(lastResponse);
        }
      }
      return lastResponseContent;
    } catch (error) {
      var _options$progressObse6;
      (_options$progressObse6 = options.progressObservable) === null || _options$progressObse6 === void 0 ? void 0 : _options$progressObse6.setValue({
        guid,
        file: options.file,
        chunkCount,
        uploadedChunks: 0,
        completed: false,
        error
      });
      throw error;
    }
  }
  async webkitFileHandler(fileEntry, contentPath, options) {
    await new Promise((resolve, reject) => {
      fileEntry.file(async (f2) => {
        await this.file({
          file: f2,
          ...options,
          parentPath: contentPath
        });
        resolve();
      }, (err) => reject(err));
    });
  }
  async webkitDirectoryHandler(directory, contentPath, options) {
    let readEntries = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    const folder = await this.repository.post({
      content: {
        Name: directory.name
      },
      parentPath: contentPath,
      contentType: "Folder"
    });
    if (readEntries) {
      const dirReader = directory.createReader();
      await new Promise((resolve, reject) => {
        dirReader.readEntries(async (items) => {
          await this.webkitItemListHandler(items, folder.d.Path, true, options);
          resolve();
        }, (err) => reject(err));
      });
    }
  }
  async webkitItemListHandler(items, contentPath, createFolders, options) {
    for (const item of items) {
      if (createFolders && item.isDirectory) {
        await this.webkitDirectoryHandler(item, contentPath, options);
      }
      if (item.isFile) {
        await this.webkitFileHandler(item, contentPath, options);
      }
    }
  }
  /**
   * Uploads content from a specified Drop Event
   * @param { UploadOptions } options Options for the Upload request
   */
  async fromDropEvent(options) {
    if (window.webkitRequestFileSystem) {
      const entries = options.event.dataTransfer ? [].map.call(options.event.dataTransfer.items, (i) => i.webkitGetAsEntry()) : [];
      await this.webkitItemListHandler(entries, options.parentPath, options.createFolders, options);
    } else {
      var _options$event$dataTr;
      ((_options$event$dataTr = options.event.dataTransfer) === null || _options$event$dataTr === void 0 ? void 0 : _options$event$dataTr.files) && [].forEach.call(options.event.dataTransfer.files, async (f2) => {
        if (f2.type === "file") {
          return await this.file({
            file: f2,
            ...options
          });
        }
      });
    }
  }
  /**
   * Uploads files (and optionally creates the directory structure) from a file list
   * @param { UploadFromFileListOptions } options Options for the Upload request
   */
  async fromFileList(options) {
    if (options.createFolders) {
      const directories = new Set(Array.from(options.fileList).map((f2) => PathHelper.getParentPath(f2.webkitRelativePath || f2.fullPath || "")));
      const directoriesBySegments = Array.from(directories).map((d) => PathHelper.getSegments(d));
      const createdDirectories = /* @__PURE__ */ new Set();
      for (const directory of directoriesBySegments) {
        let currentPath = options.parentPath;
        for (const segment of directory) {
          const pathToCreate = PathHelper.joinPaths(currentPath, segment);
          if (!createdDirectories.has(pathToCreate)) {
            await this.webkitDirectoryHandler({
              name: segment
            }, currentPath, options, false);
          }
          createdDirectories.add(pathToCreate);
          currentPath = pathToCreate;
        }
      }
      await Promise.all(Array.from(options.fileList).map(async (file) => {
        await this.file({
          ...options,
          parentPath: PathHelper.joinPaths(options.parentPath, PathHelper.getParentPath(file.webkitRelativePath)),
          file
        });
      }));
    } else {
      const {
        fileList,
        createFolders,
        ...uploadOptions
      } = options;
      for (const file of Array.from(options.fileList)) {
        await this.file({
          ...uploadOptions,
          file
        });
      }
    }
  }
};

// ../../node_modules/@sensenet/client-core/dist/esm/Repository/Versioning.js
var Versioning = class {
  /**
   * Returns a collection of content versions
   * @param {number | string} idOrPath The unique identifier or full path of the original content
   * @param {ODataParams<T> | undefined} oDataOptions optional OData options
   * @returns {Promise<ODataCollectionResponse<T>>} A promise that will be resolved with the versions
   */
  getVersions(idOrPath, oDataOptions) {
    return this.repository.loadCollection({
      path: PathHelper.joinPaths(PathHelper.getContentUrl(idOrPath), "Versions"),
      oDataOptions
    });
  }
  /**
   * Checks out the content item to the current user
   * @param {number | string} idOrPath The unique identifier or full path of the content to check out
   * @param {ODataParams<T>} oDataOptions Optional OData options
   * @returns {Promise<T>} A promise that will be resolved with the checked out version of the content item
   */
  checkOut(idOrPath, oDataOptions) {
    return this.repository.executeAction({
      name: "Checkout",
      idOrPath,
      method: "POST",
      body: void 0,
      oDataOptions
    });
  }
  /**
   * Checks in the content item
   * @param {number | string} idOrPath The unique identifier or full path of the content to check in
   * @param {string} checkInComments Optional comments for the check in operation
   * @param {ODataParams<T>} oDataOptions Optional OData options
   * @returns {Promise<T>} A promise that will be resolved with the new checked in version of the content item
   */
  checkIn(idOrPath) {
    let checkInComments = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    let oDataOptions = arguments.length > 2 ? arguments[2] : void 0;
    return this.repository.executeAction({
      name: "CheckIn",
      idOrPath,
      method: "POST",
      body: {
        checkInComments
      },
      oDataOptions
    });
  }
  /**
   * Performs an undo check out operation on a content item
   * @param {number | string} idOrPath The unique identifier or full path of the content
   * @param {ODataParams<T>} oDataOptions Optional OData options
   * @returns {Promise<T>} A promise that will be resolved with the previous checked in version of the content item
   */
  undoCheckOut(idOrPath, oDataOptions) {
    return this.repository.executeAction({
      name: "UndoCheckOut",
      idOrPath,
      method: "POST",
      body: void 0,
      oDataOptions
    });
  }
  /**
   * Performs a force undo check out operation on a content item
   * @param {number | string} idOrPath The unique identifier or full path of the content
   * @param {ODataParams<T>} oDataOptions Optional OData options
   * @returns {Promise<T>} A promise that will be resolved with the previous checked in version of the content item
   */
  forceUndoCheckOut(idOrPath, oDataOptions) {
    return this.repository.executeAction({
      name: "ForceUndoCheckout",
      idOrPath,
      method: "POST",
      body: void 0,
      oDataOptions
    });
  }
  /**
   * Performs an approve operation on a content
   * @param idOrPath The unique identifier or full path of the content to approve
   * @param oDataOptions Optional OData options
   * @returns {Promise<ODataResponse<T>>} A promise that will be resolved when the operation finished
   */
  approve(idOrPath, oDataOptions) {
    return this.repository.executeAction({
      name: "Approve",
      idOrPath,
      method: "POST",
      body: void 0,
      oDataOptions
    });
  }
  /**
   * Performs a reject operation on a content
   * @param idOrPath The unique identifier or full path of the content
   * @param oDataOptions Optional OData options
   * @returns {Promise<ODataResponse<T>>} A promise that will be resolved when the operation finished
   */
  reject(idOrPath) {
    let rejectReason = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    let oDataOptions = arguments.length > 2 ? arguments[2] : void 0;
    return this.repository.executeAction({
      name: "Reject",
      idOrPath,
      method: "POST",
      body: {
        rejectReason
      },
      oDataOptions
    });
  }
  /**
   * Performs a Publish operation on a content
   * @param idOrPath The unique identifier or full path of the content to publish
   * @param oDataOptions Optional OData options
   * @returns {Promise<ODataResponse<T>>} A promise that will be resolved when the operation finished
   */
  publish(idOrPath, oDataOptions) {
    return this.repository.executeAction({
      name: "Publish",
      idOrPath,
      method: "POST",
      body: void 0,
      oDataOptions
    });
  }
  /**
   * Performs a reject operation on a content
   * @param idOrPath The unique identifier or full path of the content
   * @param oDataOptions Optional OData options
   * @returns {Promise<ODataResponse<T>>} A promise that will be resolved when the operation finished
   */
  restoreVersion(idOrPath) {
    let version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    let oDataOptions = arguments.length > 2 ? arguments[2] : void 0;
    return this.repository.executeAction({
      name: "RestoreVersion",
      idOrPath,
      method: "POST",
      body: {
        version
      },
      oDataOptions
    });
  }
  /**
   * Lets administrators take over the lock of a checked out document from anotheruser.
   * A new locker user can be provided using the 'user' parameter (user path or id as string).
   * If left empty, the current user will take the lock.
   * @param {number | string} idOrPath The locked content's identifier or full path
   * @param {number | string | undefined} userIdOrPath Path or id of the new locker user. Will be the current user, if not provided
   * @returns {Promise<void>} A promise that will be resolved when the operation finished.
   */
  takeLockOver(idOrPath, userIdOrPath) {
    return this.repository.executeAction({
      name: "TakeLockOver",
      idOrPath,
      method: "POST",
      body: {
        user: userIdOrPath || null
      }
    });
  }
  constructor(repository) {
    this.repository = repository;
  }
};

// ../../node_modules/@sensenet/client-core/dist/esm/Repository/Repository.js
var isExtendedError = (e) => {
  return e.response ? true : false;
};
var Repository = class {
  /**
   * Disposes the Repository object
   */
  dispose() {
    this.authentication.dispose();
  }
  /**
   * Authentication service associated with the repository object
   */
  /**
   * Async method that will be resolved when the Repository is ready to make HTTP calls
   */
  async awaitReadyState() {
    await Promise.all([this.authentication.checkForUpdate()]);
  }
  /**
   * Wrapper for a native window.fetch method. The repository's readyState will be awaited and credentials will be included by default
   * @param {RequestInfo} input The RequestInfo object
   * @param {RequestInit} init Optional init parameters
   */
  async fetch(input, init) {
    let awaitReadyState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (awaitReadyState) {
      await this.awaitReadyState();
    }
    const request = new Request(input, init);
    if (this.configuration.token) {
      request.headers.append("Authorization", `Bearer ${this.configuration.token}`);
    }
    return await this.fetchMethod(request);
  }
  /**
   * Gets a more meaningful error object from a specific response
   * @param response The Response object to extract the message
   */
  async getErrorFromResponse(response) {
    let msgFromBody = "";
    let body = {};
    let text = "";
    try {
      body = await response.json();
      msgFromBody = body.error.message.value;
    } catch (error2) {
    }
    try {
      text = await response.text();
    } catch (error2) {
    }
    const error = new Error(msgFromBody || text || response.statusText);
    error.body = body;
    error.response = response;
    error.text = text;
    error.statusCode = response.status;
    error.statusText = response.statusText;
    error.url = response.url;
    return error;
  }
  /**
   * Loads a content from the content repository. If used with a fully qualified content path,
   * it will be transformed to an item path.
   * @param options Options for the Load request
   */
  async load(options) {
    const contentPath = PathHelper.getContentUrl(options.idOrPath);
    const params = ODataUrlBuilder.buildUrlParamString(this.configuration, options.oDataOptions);
    const path = PathHelper.joinPaths(this.configuration.repositoryUrl, this.configuration.oDataToken, contentPath);
    const response = await this.fetch(`${path}?${params}`, {
      ...options.requestInit,
      credentials: "include",
      method: "GET"
    });
    if (!response.ok) {
      throw await this.getErrorFromResponse(response);
    }
    return await response.json();
  }
  /**
   * Loads a content collection from the repository
   * @param options Options for the Load request
   */
  async loadCollection(options) {
    const params = ODataUrlBuilder.buildUrlParamString(this.configuration, options.oDataOptions);
    const path = PathHelper.joinPaths(this.configuration.repositoryUrl, this.configuration.oDataToken, options.path);
    const response = await this.fetch(`${path}?${params}`, {
      ...options.requestInit,
      credentials: "include",
      method: "GET"
    });
    if (!response.ok) {
      throw await this.getErrorFromResponse(response);
    }
    return await response.json();
  }
  /**
   * Returns the count of items in the requested collection.
   * The value depends on other optional query string parameters ($top, $skip, $filter, query, etc.) and does not depend on the $inlinecount parameter.
   */
  async count(options) {
    const params = ODataUrlBuilder.buildUrlParamString(this.configuration, options.oDataOptions);
    const path = PathHelper.joinPaths(this.configuration.repositoryUrl, this.configuration.oDataToken, options.path);
    const response = await this.fetch(`${path}/$count?${params}`, {
      ...options.requestInit,
      credentials: "include",
      method: "GET"
    });
    if (!response.ok) {
      throw await this.getErrorFromResponse(response);
    }
    return await response.json();
  }
  /**
   * Posts a new content to the content repository
   * @param options Post request Options
   */
  async post(options) {
    const path = PathHelper.joinPaths(this.configuration.repositoryUrl, this.configuration.oDataToken, options.parentPath);
    const params = ODataUrlBuilder.buildUrlParamString(this.configuration, options.oDataOptions);
    const postBody = Object.assign({}, options.content);
    postBody.__ContentType = options.contentType;
    postBody.__ContentTemplate = options.contentTemplate;
    const response = await this.fetch(`${path}?${params}`, {
      ...options.requestInit,
      credentials: "include",
      method: "POST",
      body: JSON.stringify(postBody)
    });
    if (!response.ok) {
      throw await this.getErrorFromResponse(response);
    }
    if (response.status === 204) {
      return Promise.resolve({
        d: null
      });
    }
    return await response.json();
  }
  /**
   * Updates an existing content in the repository using OData Patch
   * @param options Options for the Patch request
   */
  async patch(options) {
    const contentPath = PathHelper.getContentUrl(options.idOrPath);
    const path = PathHelper.joinPaths(this.configuration.repositoryUrl, this.configuration.oDataToken, contentPath);
    const params = ODataUrlBuilder.buildUrlParamString(this.configuration, options.oDataOptions);
    const response = await this.fetch(`${path}?${params}`, {
      ...options.requestInit,
      credentials: "include",
      method: "PATCH",
      body: JSON.stringify(options.content)
    });
    if (!response.ok) {
      throw await this.getErrorFromResponse(response);
    }
    return await response.json();
  }
  /**
   * Updates an existing content in the repository using OData Put
   * @param options Options for the Put request
   */
  async put(options) {
    const contentPath = PathHelper.getContentUrl(options.idOrPath);
    const path = PathHelper.joinPaths(this.configuration.repositoryUrl, this.configuration.oDataToken, contentPath);
    const params = ODataUrlBuilder.buildUrlParamString(this.configuration, options.oDataOptions);
    const response = await this.fetch(`${path}?${params}`, {
      ...options.requestInit,
      credentials: "include",
      method: "PUT",
      body: JSON.stringify(options.content)
    });
    if (!response.ok) {
      throw await this.getErrorFromResponse(response);
    }
    return await response.json();
  }
  createArray(param) {
    if (!(param instanceof Array)) {
      return [param];
    }
    return param;
  }
  /**
   * Deletes a content or a content collection from the Repository
   * @param options Options for the Delete request
   */
  async delete(options) {
    var _options$permanent;
    return await this.executeAction({
      idOrPath: ConstantContent.PORTAL_ROOT.Path,
      method: "POST",
      name: "DeleteBatch",
      requestInit: options.requestInit,
      body: {
        paths: this.createArray(options.idOrPath),
        permanent: (_options$permanent = options.permanent) !== null && _options$permanent !== void 0 ? _options$permanent : false
      }
    });
  }
  /**
   * Moves a content or content collection to a specified location
   * @param options Options for the Move request
   */
  async move(options) {
    return await this.executeAction({
      idOrPath: ConstantContent.PORTAL_ROOT.Path,
      method: "POST",
      name: "MoveBatch",
      requestInit: options.requestInit,
      body: {
        paths: this.createArray(options.idOrPath),
        targetPath: options.targetPath
      }
    });
  }
  /**
   * Copies a content or content collection to a specified location
   * @param options Options for the Copy request
   */
  async copy(options) {
    return await this.executeAction({
      idOrPath: ConstantContent.PORTAL_ROOT.Path,
      method: "POST",
      name: "CopyBatch",
      requestInit: options.requestInit,
      body: {
        paths: this.createArray(options.idOrPath),
        targetPath: options.targetPath
      }
    });
  }
  async getPropertyValue(idOrPath, propertyName) {
    const path = PathHelper.joinPaths(this.configuration.repositoryUrl, this.configuration.oDataToken, PathHelper.getContentUrl(idOrPath), propertyName, "$value");
    const response = await this.fetch(path);
    if (!response.ok) {
      throw await this.getErrorFromResponse(response);
    }
    return await response.text();
  }
  async getMetadata(idOrPath) {
    const path = idOrPath === void 0 ? PathHelper.joinPaths(this.configuration.repositoryUrl, this.configuration.oDataToken, "$metadata") : PathHelper.joinPaths(this.configuration.repositoryUrl, this.configuration.oDataToken, PathHelper.getContentUrl(idOrPath), "$metadata");
    const response = await this.fetch(`${path}?$format=json`);
    if (!response.ok) {
      throw await this.getErrorFromResponse(response);
    }
    return await response.json();
  }
  /**
   * Shares a content or content collection with a specified
   * @param options Options for the Copy request
   */
  async share(options) {
    var _options$sendNotifica;
    return await this.executeAction({
      idOrPath: options.content.Id,
      method: "POST",
      name: "Share",
      body: {
        token: options.identity.toString(),
        content: options.content,
        level: options.sharingLevel,
        mode: options.sharingMode,
        sendNotification: (_options$sendNotifica = options.sendNotification) !== null && _options$sendNotifica !== void 0 ? _options$sendNotifica : true
      }
    });
  }
  /**
   * Retrieves a list of content actions for a specified content
   * @param options Options for fetching the Custom Actions
   */
  async getActions(options) {
    const contextPath = PathHelper.getContentUrl(options.idOrPath);
    const path = PathHelper.joinPaths(this.configuration.repositoryUrl, this.configuration.oDataToken, contextPath, "Actions");
    const response = await this.fetch(`${path}${options.scenario ? `?scenario=${options.scenario}` : ""}`, {
      credentials: "include",
      method: "GET"
    });
    if (!response.ok) {
      throw await this.getErrorFromResponse(response);
    }
    return await response.json();
  }
  /**
   * Returns data for loading Office document for editing
   * @param idOrPath Id or path of the document
   */
  async getWopiData(options) {
    return await this.executeAction({
      idOrPath: options.idOrPath,
      method: "GET",
      name: "GetWopiData",
      requestInit: options.requestInit,
      oDataOptions: {
        ...options.odataOptions,
        action: options.action || "edit"
      }
    });
  }
  /**
   * Executes a specified custom OData action
   * @param options Options for the Custom Action
   */
  async executeAction(options) {
    const contextPath = PathHelper.getContentUrl(options.idOrPath);
    let params = ODataUrlBuilder.buildUrlParamString(this.configuration, options.oDataOptions);
    const path = PathHelper.joinPaths(this.configuration.repositoryUrl, this.configuration.oDataToken, contextPath, options.name);
    const requestOptions = {
      ...options.requestInit,
      credentials: "include",
      method: options.method
    };
    if (options.method === "POST") {
      requestOptions.body = JSON.stringify(options.body);
    } else {
      options.body && Object.keys(options.body).forEach((key) => params += `&${key}=${encodeURIComponent(options.body[key])}`);
    }
    const response = await this.fetch(`${path}?${params}`, requestOptions);
    if (!response.ok) {
      throw await this.getErrorFromResponse(response);
    }
    if (response.status === 204) {
      return Promise.resolve({});
    }
    return await response.json();
  }
  /**
   * Shortcut for security- and permission-related custom actions
   */
  /**
   * Reloads the content schemas from the sensenet backend
   * @returns {Promise<void>} A promise that will be resolved / rejected based on the action success
   */
  async reloadSchema() {
    const schemas = await this.executeAction({
      idOrPath: "Root",
      name: "GetSchema",
      method: "GET",
      body: void 0
    });
    this.schemas.setSchemas(schemas);
  }
  constructor(config) {
    let fetchMethod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : window && window.fetch && window.fetch.bind(window);
    let schemas = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new SchemaStore();
    this.fetchMethod = fetchMethod;
    this.schemas = schemas;
    this.authentication = new BypassAuthentication();
    this.configuration = void 0;
    this.security = new Security(this);
    this.versioning = new Versioning(this);
    this.upload = new Upload(this);
    this.preview = new Preview(this);
    this.allowedChildTypes = new AllowedChildTypes(this);
    this.configuration = {
      ...defaultRepositoryConfiguration,
      ...config
    };
    this.schemas.setSchemas(this.configuration.schemas);
  }
};

// ../../node_modules/@sensenet/client-core/dist/esm/Authentication/FormsAuthenticationService.js
var FormsAuthenticationService = class _FormsAuthenticationService {
  /**
   * Static Factory Method for attaching the service to a Repository object
   * @param repository The repository instance
   * @param loadUserOptions Additional options for loading User content
   */
  static Setup(repository, loadUserOptions) {
    const service = new _FormsAuthenticationService(repository, loadUserOptions);
    service.getCurrentUser();
    return service;
  }
  /**
   * This observable indicates the current state of the service
   * @default LoginState.Pending
   */
  constructor(repository) {
    let userLoadOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      select: "all"
    };
    this.repository = repository;
    this.userLoadOptions = userLoadOptions;
    this.statusLock = new import_semaphore_async_await.default(1);
    this.state = new ObservableValue(LoginState.Unknown);
    this.currentUser = new ObservableValue(ConstantContent.VISITOR_USER);
    this.repository.authentication = this;
  }
  /**
   * Disposes the service, the state and currentUser observables
   */
  async dispose() {
    this.state.dispose();
    this.currentUser.dispose();
  }
  /**
   * Placehlolder to check if a token update is needed. Not used with Forms authentication
   */
  async checkForUpdate() {
    return false;
  }
  /**
   * Returns the current user value
   */
  async getCurrentUser() {
    try {
      await this.statusLock.acquire();
      this.state.setValue(LoginState.Pending);
      try {
        const result = await this.repository.loadCollection({
          path: ConstantContent.PORTAL_ROOT.Path,
          oDataOptions: {
            ...this.userLoadOptions,
            query: "Id:@@CurrentUser.Id@@",
            top: 1
          }
        });
        if (result.d.__count === 1) {
          if (result.d.results[0].Id !== ConstantContent.VISITOR_USER.Id) {
            this.state.setValue(LoginState.Authenticated);
            this.currentUser.setValue(result.d.results[0]);
            return result.d.results[0];
          }
        }
      } catch {
      }
      this.state.setValue(LoginState.Unauthenticated);
      this.currentUser.setValue(ConstantContent.VISITOR_USER);
      return ConstantContent.VISITOR_USER;
    } finally {
      await this.statusLock.release();
    }
  }
  /**
   * Logs in with the provided credentials
   * @param username The username for the login
   * @param password The password for the login
   */
  async login(username, password) {
    try {
      await this.statusLock.acquire();
      const user = await this.repository.executeAction({
        body: {
          username,
          password
        },
        method: "POST",
        idOrPath: ConstantContent.PORTAL_ROOT.Id,
        name: "Login"
      });
      this.currentUser.setValue(user.d);
      const isVisitor = user.d.Id !== ConstantContent.VISITOR_USER.Id ? true : false;
      this.state.setValue(isVisitor ? LoginState.Authenticated : LoginState.Unauthenticated);
      return isVisitor;
    } catch (error) {
      return false;
    } finally {
      this.statusLock.release();
    }
  }
  /**
   * Logs out and destroys the current session
   */
  async logout() {
    try {
      await this.repository.executeAction({
        method: "POST",
        idOrPath: ConstantContent.PORTAL_ROOT.Id,
        name: "Logout",
        body: {}
      });
    } catch (error) {
    }
    this.currentUser.setValue(ConstantContent.VISITOR_USER);
    this.state.setValue(LoginState.Unauthenticated);
    return true;
  }
};

// ../../node_modules/@sensenet/client-core/dist/esm/Models/RequestOptions.js
var SharingLevel;
(function(SharingLevel2) {
  SharingLevel2["Open"] = "Open";
  SharingLevel2["Edit"] = "Edit";
})(SharingLevel || (SharingLevel = {}));
var SharingMode;
(function(SharingMode2) {
  SharingMode2["Private"] = "Private";
  SharingMode2["Authenticated"] = "Authenticated";
  SharingMode2["Public"] = "Public";
})(SharingMode || (SharingMode = {}));
export {
  AllowedChildTypes,
  BypassAuthentication,
  ConstantContent,
  DEFAULT_SERVICE_TOKEN,
  FormsAuthenticationService,
  LoginState,
  ODataUrlBuilder,
  Preview,
  Repository,
  SchemaStore,
  Security,
  SharingLevel,
  SharingMode,
  Upload,
  Versioning,
  defaultRepositoryConfiguration,
  isExtendedError
};
/*! Bundled license information:

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@sensenet_client-core.js.map
